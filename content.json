{"meta":{"title":"huklee's blog","subtitle":null,"description":null,"author":"huklee","url":"https://huklee.github.io"},"pages":[{"title":"Tags","date":"2017-01-17T23:36:18.000Z","updated":"2017-01-17T23:36:18.000Z","comments":true,"path":"tags/index.html","permalink":"https://huklee.github.io/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-01-17T23:36:07.000Z","updated":"2017-01-17T23:36:07.000Z","comments":true,"path":"categories/index.html","permalink":"https://huklee.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"hexo visitor counter","slug":"042.hexo-visitor-counter","date":"2017-02-16T14:59:30.000Z","updated":"2017-02-16T15:17:56.000Z","comments":true,"path":"2017/02/16/042.hexo-visitor-counter/","link":"","permalink":"https://huklee.github.io/2017/02/16/042.hexo-visitor-counter/","excerpt":"","text":"Useful linksbunsanzi visitor countertea3 popular postsissan hexo theme","categories":[{"name":"draft","slug":"draft","permalink":"https://huklee.github.io/categories/draft/"}],"tags":[{"name":"draft","slug":"draft","permalink":"https://huklee.github.io/tags/draft/"}]},{"title":"branch and bound algorithm","slug":"041.branch-and-bound","date":"2017-02-16T12:23:51.000Z","updated":"2017-02-16T15:17:50.000Z","comments":true,"path":"2017/02/16/041.branch-and-bound/","link":"","permalink":"https://huklee.github.io/2017/02/16/041.branch-and-bound/","excerpt":"","text":"Branch and boundNP-Hard 등의 문제를 풀 때, 가지치기를 효과적으로 하며 최적의 해를 탐색하는 기법 중 하나. Branch별로 Bound와 탐색 중에 발견된 Maxprofit을 비교하여 Prunning을 하는 기법이다. 즉, branch별로 선택하는 경우에 대한 Bound (주어진 상황에서 예상되는 최대의 결과)를 계산하여 이를 선택의 제외의 기준으로 삼는 방법이다. 처음에 이해하기는 조금 헷갈리는 개념이지만, 실제로 그림을 그리면서 진행해보면 생각만큼 이해하기는 어렵지 않은 주제이다. TSP를 예를 들어서, 남은 선택 중에서 모두 최선의 선택을 한다고 가정할 경우에 나오는 예상 값을 각각 bound로 계산한다. TSP의 목표는 탐색비용의 최소화이므로, bound는 lower bound가 될 것이다. 탐색을 하면서 각 branch별로 bound를 먼저 계산하고 가장 bound가 낮은 것부터 탐색한다. 순회를 계속해 진행하면서 maxprofit을 갱신해 나간다. maxprofit보다 bound가 높은 node의 경우는 더 이상 진행할 필요가 없으므로 추가로 탐색하지 않는 것을 반복한다. 끝. 간단하면서도 효과가 뛰어난 NP-Hard 해결 방법 중 하나이다. best-first search 방법을 섞어서 사용하면 조금 더 탐색의 효율이 개선될 것으로 보인다. 검증할 필요는 있어 보이지만.. 문제구현Useful linksBranch and bound in TSP Branch and bound in knapsack Best-first search : greedy BFS in knapsack Sahaj Computer Solutions : backtracking @ knapsack problem","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/tags/algorithm/"},{"name":"NP-Hard","slug":"NP-Hard","permalink":"https://huklee.github.io/tags/NP-Hard/"},{"name":"TSP","slug":"TSP","permalink":"https://huklee.github.io/tags/TSP/"},{"name":"draft","slug":"draft","permalink":"https://huklee.github.io/tags/draft/"}]},{"title":"algorithm test guides","slug":"040.algorithm-test-guides","date":"2017-02-16T06:53:11.000Z","updated":"2017-02-16T07:11:47.000Z","comments":true,"path":"2017/02/16/040.algorithm-test-guides/","link":"","permalink":"https://huklee.github.io/2017/02/16/040.algorithm-test-guides/","excerpt":"","text":"알고리즘 문제 제대로 잘 풀기삼성 SW 검정시험(Certificate Test) 가이드 (Professional, Expert)약 12년 동안 알고리즘 문제풀이 강사를 하였고, 삼성전자 인재개발원에서도 강의를 오랫동안 하고 계신 장홍준님의 문제풀이 팁. 간단히 요약을 하자면 다음과 같다. 알고리즘 문제를 잘 풀 수 있는 실력 늘리기 기초적인 알고리즘에 대한 깊은 이해가 필요 다양한 문제를 풀어보고, 실제로 코딩을 진행해야 함 알고리즘의 뛰어난 구현능력을 갖추어야 함. 구체적으로는 다음 세 가지를 갖추어야 함. 정확한 코드 수행시간이 짧도록 빠르게 구현하는 능력특히나 정확한 코드 구현 능력이 중요하다. 빠르게 구현하는 능력보다 디버깅 시간을 줄이는 것이 효과적이기 떄문이다. 알고리즘 시험을 잘 보는 방법 문제를 정확히 잘 읽어야 한다. 할 수 있는 한 끝까지 최선을 다해야 한다. 문제에서 놓친 것은 없는 지 꼼꼼하게 확인해야 한다. 테스트 케이스를 여러가지로 만들어서 끝까지 edge cases를 파악해야 한다. 이전에 풀었던 문제 혹은 알고리즘에 끼워맞추거나 기억을 더듬어 풀으려 하지 말라. Useful links프로그램을 배웠으나 알고리즘 시험을 봐야 한다면 10편 프로그램을 배웠으나 알고리즘 시험을 봐야 한다면 9편 프로그램을 배웠으나 알고리즘 시험을 봐야 한다면 8편 프로그램을 배웠으나 알고리즘 시험을 봐야 한다면 7편 프로그램을 배웠으나 알고리즘 시험을 봐야 한다면 6편 프로그램을 배웠으나 알고리즘 시험을 봐야 한다면 5편 프로그램을 배웠으나 알고리즘 시험을 봐야 한다면 4편 프로그램을 배웠으나 알고리즘 시험을 봐야 한다면 3편 프로그램을 배웠으나 알고리즘 시험을 봐야 한다면 2편 프로그램을 배웠으나 알고리즘 시험을 봐야 한다면 1편","categories":[],"tags":[]},{"title":"1st-Deepcon-info-Seoul-2nd-Day","slug":"039.1st-Deepcon-info-Seoul-2nd-Day","date":"2017-02-16T02:39:45.000Z","updated":"2017-02-16T05:14:32.000Z","comments":true,"path":"2017/02/16/039.1st-Deepcon-info-Seoul-2nd-Day/","link":"","permalink":"https://huklee.github.io/2017/02/16/039.1st-Deepcon-info-Seoul-2nd-Day/","excerpt":"","text":"2일차","categories":[{"name":"Conference","slug":"Conference","permalink":"https://huklee.github.io/categories/Conference/"}],"tags":[{"name":"Deep learning","slug":"Deep-learning","permalink":"https://huklee.github.io/tags/Deep-learning/"},{"name":"Machine learning","slug":"Machine-learning","permalink":"https://huklee.github.io/tags/Machine-learning/"}]},{"title":"1st Deepcon.info @ Seoul","slug":"038.1st-Deepcon-info-Seoul-1st-Day","date":"2017-02-16T01:47:11.000Z","updated":"2017-02-16T12:43:53.000Z","comments":true,"path":"2017/02/16/038.1st-Deepcon-info-Seoul-1st-Day/","link":"","permalink":"https://huklee.github.io/2017/02/16/038.1st-Deepcon-info-Seoul-1st-Day/","excerpt":"","text":"제1회 딥러닝 컨퍼런스 2017 1일차주최 : 서형석 대표 @ 딥러닝그룹 1. 베이지안 딥러닝 - 김용대 : 서울대학교 통계학과slides IntroBayesian에 전반적인 내용을 다룰 예정. 끝 부분에서 베이지안 딥러닝에 대해서 언급하고 발표를 마칠 예정임. 사후분포Posterior distribution는 우도함수Likelihood function 과 사전분포Prior distribution의 곱에 비례한다. 시간에 따라서 분포가 변하는 상황에 대해서 bayesian 접근은 꽤나 좋은 접근방식이 될 수 있다. 장점 : prediction의 정확도가 매우 높은 편 / Uncertainty quantization 불확실성에 대한 확률을 계산하기 좋다 단점 : computation is hard / Need full observation of distribution Bayesian computation크게 세 가지로 나누어진다. 손으로 구하기 / monte-carlo 사용하기 / approximation 사용하기 (나머지 3개) Analytical approaches with conjugate priors Monte-Carlo method Variational Inference Assumed Density Filtering Expectation Propagation assume density의 확장판 Deep learning with bayesian 모델시작한 지 얼마 되지 않아서 아직 가시적인 연구결과에 대해서는 적용된 것이 없다. 딥러닝의 여러 가지 아키텍쳐 deep neural network deep belief network / deep boltzmann machine stack encoder 실제로는 deep neural network만 사용되고 나머지는 참고로만 알아두면 된다. 주로 CNN, RNN이 사용된다는 것마 알아두면, 상관없다. Deep latent gaussian model (DLGM)Probabilistic Neural Network Models 둘 다 모두 수학적으로 엄청나게 어려운 계산이 들어가는 부분이라 이해하고 사용하기가 쉽지 않다. approximation을 하는 방법이 다양하게 가능하다. 2. deep generative model 관련 최근 연구들 - 신진우 : KAIST 전기전자Recent trends classification : CNN natural language process : RNN Generative deep learning Application : image regeneration &amp; recommendation example generate a image for the style of artist making a 복원된 image image compression Part I : graphical model approach Markov random field, restricted Boltzmann machine Approach Gibbs distribution MRF(Markov Random Field) / RBM(Restricted Boltzmann Machines) / DBM(Depp Boltzmann Machines): two-state markov state Part II : Neural network approach de-noising auto-encoder, variational auto-generator 가장 Hot한 토픽 논문 Generatvie adversarial Network (GAN) [Goodfellow et al.2014] Deep convolutional GAN [radford et al. 2015] Game and decision making deep reinforcement learning Research in agorithmic intelligence lab image compression via neural networks jpeg을 뛰어 넘는 그림 압축 알고리즘 만들어내기 : rate 120 굉장히 의미 있는 가시적 결과가 나오고 있음 NP-Hard 문제 도전하기 : TSP 문제 Lab 서버 운영 Lab에서 사용하고 있는 GPU 서버 50대 운영 : Titan X 유명한 해외 Lab은 100대 정도는 돌리는 경우도 많다고 함 3. Building Deep Learning - 김인중 : 한동대학교A Review of a Neural Network algorithmsvector형태로 표현할 수 있는 모든 데이터는 Neural Network의 입력, 혹은 출력으로 사용될 수 있다. Implmentation of Neural NetworkC++로 구현한 HGU Neural Network Deep learning algorithms on GPU 특징 GPU 특성상 ALU가 수백개에서 수천개를 내부에 가지고 있다. 성능 일반적으로는 딥 러닝 알고리즘을 적용할 때 CPU에 비해서 이미지 인식은 60배 정도 빠르며, training을 하는 데 있어서는 20배 정도 성능의 차이가 난다. 주의할 점 parallel하게 연산을 처리할 수 있는 상황이 아니라면 오히려 CPU보다 연산이 느릴 수도 있는 상황이 존재할 수 있으니 주의해야 한다. Neural Networks Demonstration on XOR 직접 소스코드를 짜 보면, 많으 부분 deep learning에 대한 이해도가 높아진다. learning rate은 왠만하면 작게 하는 게 좋음 (0.001 정도) Generated Neural Networks ex&gt; autoencoder, restricted Boltzmann Machines generated같은 경우는 원래 자신의 형태를 다시 만들어야 하는 constraint를 가지고 있다. 따라서 hidden layer가 일반적인 NN에 비해서 많이 가지고 있게 된다. generated가 일반적인 NN 보다는 훨씬 어려운 문제를 다루고 있다고 볼 수 있으며, 응용할 수 있는 분야도 많다고 볼 수 있다. Restricted Boltzmann Machines : RBM 역시 양방향 네트워크의 특성을 가지고 있음. energy function + sigmoid function으로 표현됨 RBM input / output RBM probability functions RNN : Recurrent Neural NetworkMain features RNNs are Turing-complete sequence to sequence mapping best approach to following problems Speech recognition skype translation (error rate goes 45% -&gt; 17%:LSTM) handwriting recognition machine translation problems in RNN vanishing gradient problems long term dependency의 문제가 있음 But, LSTM approach solved this problem 더 자세한 설명은 다음 참고 Understanding LSTM RNN Practical Advices deep learning을 제대로 이해하는 데 있어서 실제로 알고리즘의 내부를 실제로 코딩을 하는 것을 크게 추천한다. 하지만, 굉장히 복잡한 작업이며, 특히나 CNN, RNN 등은 그 복잡도가 엄청 어렵다. Theory를 완전히 이해해야만 수식을 하나하나 되집어 가면서 봐야만 한다. 특히 GPU는 fault tolerant한 특성을 가지고 있기 떄문에, 디버깅이 매우 힘든 프로그래밍 중 하나이다. 따라서, 디버깅 툴인 trace 등을 통해서 제대로 잡히지 않는 경우가 허다하다. 디버거를 통하지 않고, trace &amp; watch만으로는 힘든 부분이 있어서, 머리로 모든 알고리즘의 로직을 완성하고, 디버깅을 수행하기를 추천함. CPU 알고리즘을 먼저 구현하고, 그 다음에 GPU 알고리즘을 구현하는 것을 추천함. Q &amp; AUseful Links모두를 위한 머신러닝/딥러닝 - 김성훈 교수Deep Learning Research Blog by Andrej KarpathyUnderstanding LSTM RNNBack-propagation algorithm for MLP, CNN, RNN by 김수형 전남대 교수","categories":[{"name":"Conference","slug":"Conference","permalink":"https://huklee.github.io/categories/Conference/"}],"tags":[{"name":"Deep learning","slug":"Deep-learning","permalink":"https://huklee.github.io/tags/Deep-learning/"},{"name":"Machine learning","slug":"Machine-learning","permalink":"https://huklee.github.io/tags/Machine-learning/"}]},{"title":"light web-based coding tools","slug":"037.light-web-based-coding-tools","date":"2017-02-12T14:33:47.000Z","updated":"2017-02-12T14:49:41.000Z","comments":true,"path":"2017/02/12/037.light-web-based-coding-tools/","link":"","permalink":"https://huklee.github.io/2017/02/12/037.light-web-based-coding-tools/","excerpt":"","text":"Light web-based coding toolsWandbox사용에 제한이 없는 web-based coding open source툴. 간단한 C++는 잘 돌아가는 것을 확인헀는데, python은 동작이 제대로 안 돌아가는 것 같다. 아직 구현이 덜된건가? 여튼 C, C++를 간단히 테스트하기에는 무척이나 유용한 툴http://melpon.org/wandbox coderpad깔끔하고 사용하기 좋아보이는 coderpad. 상용 툴이라서 제한은 좀 있지만 정말 간단하게 코드를 웹에서 테스트해보기 딱 좋다. 다만, 로그인하지 않으면 곧 expire되므로, 유료사용자가 될 것이 아니면 제약이 많다.https://coderpad.io/ 지원 가능 언어들 : 거의 모든 언어가 다 된다고 보면 된다. C C# C++ Clojure CoffeeScript Erlang F# Go Haskell Java JavaScript Markdown MySQL Objective-C PHP Perl Plain Text Python 2 Python 3 R Ruby Rust Scala SwiftVisual Basic","categories":[{"name":"Tips","slug":"Tips","permalink":"https://huklee.github.io/categories/Tips/"}],"tags":[{"name":"programming","slug":"programming","permalink":"https://huklee.github.io/tags/programming/"}]},{"title":"SOLID Design principles by GoF","slug":"036.SOLID-Design-principles","date":"2017-02-10T14:01:06.000Z","updated":"2017-02-11T00:05:14.000Z","comments":true,"path":"2017/02/10/036.SOLID-Design-principles/","link":"","permalink":"https://huklee.github.io/2017/02/10/036.SOLID-Design-principles/","excerpt":"","text":"SOLID Design principles by GoFThere are five well-known software design principles from the book “Head First, Design Patterns”. Nothing’s absolute, but classical things are great enough to know and have a look on it. S : Single responsibilityO : OCP, Open / Close Principles Objects should be open for extension, but closed for modification. 클래스(객체)는 확장에 대해서는 열려있어야 한다. 하지만, 코드 변경에 대해서는 닫혀 있어야 한다. LID : Dependency Inversion Principles if you want an easier life as a coder, “depend on abstractions, not concretions” 추상화된 것에 의존하도록 만들어라. 구상 클래스에 의존하도록 만들지 않아야 한다. Useful linksSOLID design principles","categories":[{"name":"programming","slug":"programming","permalink":"https://huklee.github.io/categories/programming/"}],"tags":[{"name":"design patterns","slug":"design-patterns","permalink":"https://huklee.github.io/tags/design-patterns/"}]},{"title":"traverse algorithms","slug":"035.traverse-algorithms","date":"2017-02-07T07:47:02.000Z","updated":"2017-02-10T14:00:18.000Z","comments":true,"path":"2017/02/07/035.traverse-algorithms/","link":"","permalink":"https://huklee.github.io/2017/02/07/035.traverse-algorithms/","excerpt":"","text":"Backtracking 특징 주로 재귀호출 사용 tree traverse, 특히 state tree traverse 문제의 해결방법 모든 가능성을 뒤져보는 행위 : 느릴 수 밖에 없음 보통 지수함수 이상의 time complexity를 가진다 가지치기 (Prunning)을 사용하면 효과의 향상을 가져올 수 있음 (DFS와의 차이) rough implementation 123456789101112# recursivedef backtracking (candidate): # 01. Reject or accept answer = [] if isReject(candidate) return [] if isAccept(candidate) answer.append(candidate) # 02. Recursive call subProblem = getFirstChild(candidate) while isValid(subProblem): answer += backtracking(subProblem) subProblem = getNextChild(candidate) return answer DFS 특징 recursive / iterative 둘 다 구현 가능 iterative하게 구현할 경우 stack을 써서 candidate 관리 Time complexity : O(V + E) Space complexity : O(V) rough implementation () 1234567891011121314# recursivedef dfs(graph, start, visited=None): # 01. check visit status if visited == None: visited = set() visited.add(start) # 02. do something with the start vertex doSomething(start) # 03. recursive call candidates = [v for v in grpah.getAdj(start) if isVisited(v)] for v in candidates: dfs(graph, v, visited) BFS 특징 candiate을 queue로 구현함 iterative하게 구현해야함 (recursive로는 어려움) Time complexity : O(V + E) Space complexity : O(V) rough implementation 123456789101112131415# iterativedef bfs(graph, start): # 01. initialization visited, queue = set(), [start] while queue != []: # 02. do something with the start vertex doSomething(start) # 03. find the candidates candSet = [v in graph.getAdj(start)] for cand in candSet: if isVisited(v) in not visited: queue.append(v) queue.pop(0) Shortest path finding in graph dijkstra algorithm Bellman-ford algorithm A* search Useful linksBacktracking in Wikipedia BFS &amp; DFS in python Depth first search Breadth first search","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/tags/algorithm/"},{"name":"tree","slug":"tree","permalink":"https://huklee.github.io/tags/tree/"},{"name":"graph","slug":"graph","permalink":"https://huklee.github.io/tags/graph/"}]},{"title":"Installing Tensorflow using virtualenv on Mac","slug":"034.Installing-Tensorflow-using-virtualenv-on-Mac","date":"2017-02-07T04:00:18.000Z","updated":"2017-02-07T04:25:16.000Z","comments":true,"path":"2017/02/07/034.Installing-Tensorflow-using-virtualenv-on-Mac/","link":"","permalink":"https://huklee.github.io/2017/02/07/034.Installing-Tensorflow-using-virtualenv-on-Mac/","excerpt":"","text":"Installing tensorflow using virtualenv on Mac이전 포스트에서 Anaconda를 사용하여 설치를 했더니, jupyter에서 제대로 tensorflow와 conda env를 인식하지 못 하는 문제가 발생했다. 이래저래 많이 헤매었는데, 정답은 virtualenv와 pip를 사용하는 것이 가장 깔끔했다. 이번 포스트에서는 virtualenv + pip (python3)를 활용한 설치로 진행한다. 아나콘다는 싹 밀어버리고 진행한다. Environment &amp; prerequisites Mac air i5 1.5Ghz, 8G ram OS X Sierra 10.12.3 homebrew Installation target python 3.6.0 pip 9.0.1 tensorflow 0.9.0 etc (numpy, scipy, scikit-learn … ) Install steps 파이썬 3를 설치하자. pip3를 사용해서 설치를 하려면 기본적으로 깔아야 한다. 1$ brew install python3 다음으로는 virtualenv를 설치하자 1$ pip3 install --upgrade virtualnev 지정된 폴더에 virtualenv 설정을 새로 만들고 적용하자. activate를 해주면 다음과 같이 shell prompt 에 (tensorflow)가 붙는 것을 확인할 수 있다. 123$ virtualenv --system-site-packages ~/Work/tensorflow$ source ~/Work/tensorflow/bin/activate(tensorflow) $ tensorflow를 설치하자. pip 로 설치하며, os에 맞는 url을 설정해주고 설치를 진행하면 된다. 12(tensorflow) $ export TF_BINARY_URL=https://storage.googleapis.com/tensorflow/mac/tensorflow-0.9.0-py3-none-any.whl(tensorflow) $ pip3 install --upgrade $TF_BINARY_URL tensorflow가 잘 실행되는 지 테스트해보자. 앞에서 했던 대로 테스트해보면 된다. sample code 1234567import tensorflow as tfhello = tf.constant('Hello, TensorFlow!')sess = tf.Session()print(sess.run(hello))a = tf.constant(10)b = tf.constant(32)print(sess.run(a + b)) expected result b’Hello, TensorFlow!’ 42 추가로 필요한 패키지들을 pip로 설치해야 한다. scipy, numpy, jupyter 등을 설치해야 한다. 한번에 \u001apip 한 방으로 설치하면 편하다. 12(tensorflow) $ python3 -m pip install --upgrade pip(tensorflow) $ pip3 install --user numpy scipy matplotlib ipython jupyter pandas sympy nose 추가로 path를 추가해야 한다. 다음과 같이 export로 실행파일들이 있는 user의 실행파일 폴더를 추가하자. tensorflow virtualenv를 실행하면 자동으로 추가하기 위해서는 해당 activate script 중간에 추가하자. 1$ export PATH=\"$PATH:/Users/huklee/.local/bin\" scikit-learn 설치추가로 scikit-learn을 아래와 같이 설치하자. 마찬가지로 virtualenv로 들어와 있는 상태에서 진행해야 제대로 tensorflow 환경이 반영될 수 있다. 1(tensorflow) $ pip3 install -U scikit-learn jupyter notebook 실행jupyter notebook을 실행하자. 마찬가지로 tensorflow virtualenv를 실행시킨 상태에서 실행이 되어야 한다. 그리고 나서는 브라우저(chrome)으로 http://localhost:8888/ 에 접속하면 된다. 1(tensorflow) $ jupyter notebook DONE여기까지 하면 jupyter에서 tensorflow 및 scikit-learn, numpy, scipy, pandas 몽땅 잘 작동하는 것을 확인할 수 있다. Useful links이승철 교수님 강의 machine learning 관련 python코드 Anaconda: conda package manage How to check python’s version in running python how to uninstall Anaconda on Mac Jupyter notebook and conda Scikit-learn install tensorflow 튜토리얼","categories":[{"name":"Data Science","slug":"Data-Science","permalink":"https://huklee.github.io/categories/Data-Science/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://huklee.github.io/tags/Mac/"},{"name":"python","slug":"python","permalink":"https://huklee.github.io/tags/python/"},{"name":"Data","slug":"Data","permalink":"https://huklee.github.io/tags/Data/"},{"name":"Deep learning","slug":"Deep-learning","permalink":"https://huklee.github.io/tags/Deep-learning/"}]},{"title":"Ubuntu TIps : Ubuntu Desktop certified hardware","slug":"033.Ubuntu-TIps-Ubuntu-Desktop-certified-hardware","date":"2017-02-06T07:43:10.000Z","updated":"2017-02-06T07:46:54.000Z","comments":true,"path":"2017/02/06/033.Ubuntu-TIps-Ubuntu-Desktop-certified-hardware/","link":"","permalink":"https://huklee.github.io/2017/02/06/033.Ubuntu-TIps-Ubuntu-Desktop-certified-hardware/","excerpt":"","text":"Ubuntu 에 맞는 노트북 혹은 데스크탑 맞출 때 확인다음 사이트에서 지원되는 하드웨어인지를 확인한 후에 구입을 하도록 하자. 랩탑을 사든, 데스크탑을 사든, 참조해서 진행해야 제대로 된 성능을 낼 수 있는 드라이버를 찾는 데 문제가 없을 것 같다.Ubuntu Desktop certified hardware","categories":[{"name":"Tips","slug":"Tips","permalink":"https://huklee.github.io/categories/Tips/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://huklee.github.io/tags/Ubuntu/"},{"name":"Linux","slug":"Linux","permalink":"https://huklee.github.io/tags/Linux/"}]},{"title":"install Tensorflow on Mac air","slug":"032.install-Tensorflow-on-Mac-air","date":"2017-02-06T00:58:31.000Z","updated":"2017-02-06T04:38:11.000Z","comments":true,"path":"2017/02/06/032.install-Tensorflow-on-Mac-air/","link":"","permalink":"https://huklee.github.io/2017/02/06/032.install-Tensorflow-on-Mac-air/","excerpt":"","text":"Installing Tensorflow on Mac airtensorflow를 설치하는 방법에는 다음과 같이 다섯 가지 방법이 있다. 이 중에는 일단 가장 익숙한 Anaconda를 사용한 설치 방법을 따라가 보도록 하자. 주의할 점현재 conda를 활용한 설치에서는 일단 CPU만을 사용하는 tensorflow만 가능하다. GPU를 사용할 수 있게 하기 위해서는 cuda 설치 + pip로 tensorflow 설치 하는 두 가지 과정이 포함되어야 한다. 1. Anaconda 다운로드 받기아래 링크에서 Anaconda를 다운받아서 설치하자. python 3.6 CLI install 버전을 다운 받아서 진행했다.Anaconda download for Mac 다운로드 받은 폴더에서 다음과 같이 설치하자. 1$ source Anaconda3-4.3.0-MacOSX-x86_64.sh 쭉 yes / enter를 해 주면 설치가 5~10분 정도 걸린다. 다운로드 및 설치 당시 파일 기준의 버전은 아래와 같다. 1234$ python -V Python 3.6.0 :: Anaconda 4.3.0 (x86_64)$ conda -V conda 4.3.8 다음과 같이 conda envinronment에 텐서플로우를 추가하자. 1$ conda create -n tensorflow python=3.4 추가된 conda environment를 사용하기 위해서는 source activate [env_name] 을 사용해서 접속하면 된다. 활성화된 conda env에서 실제로 python 버전을 찍어보면 다른 버전이 나오는 것을 확인할 수 있다. 반대로 env를 나오기 위해서는 source deactivate로 나오면 된다. 12345$ python -VPython 3.6.0 :: Anaconda 4.3.0 (x86_64)$ source activate tensorflow$ (tensorflow) python -VPython 3.4.5 :: Continuum Analytics, Inc. 2. install tensorflow본격적으로 tensorflow를 설치하자. 위에서 바로 실행된 conda env가 activate된 상태에서 진행하면 된다. pip 12# should be on conda env$ (tensorflow) conda install -c conda-forge tensorflow 3. test tensorflow다음과 같은 샘플 코드를 한 번 돌려보자. 결과가 다음과 같이 나오면 성공! sample code 1234567import tensorflow as tfhello = tf.constant('Hello, TensorFlow!')sess = tf.Session()print(sess.run(hello))a = tf.constant(10)b = tf.constant(32)print(sess.run(a + b)) expected result b’Hello, TensorFlow!’ 42 추가로 예제를 돌려보기 위해서 다음 github에서 tensorflow 예제를 clone해서 가져오도록 하자. 1$ git clone https://github.com/tensorflow/tensorflow Useful linksenable GPU support anaconda tensorflow installation tensorflow Korea gitbook","categories":[{"name":"Data Science","slug":"Data-Science","permalink":"https://huklee.github.io/categories/Data-Science/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://huklee.github.io/tags/Mac/"},{"name":"python","slug":"python","permalink":"https://huklee.github.io/tags/python/"},{"name":"Data","slug":"Data","permalink":"https://huklee.github.io/tags/Data/"},{"name":"Deep learning","slug":"Deep-learning","permalink":"https://huklee.github.io/tags/Deep-learning/"}]},{"title":"Time complexity notations","slug":"031-Time-complexity-notations","date":"2017-02-04T07:57:13.000Z","updated":"2017-02-05T06:11:25.000Z","comments":true,"path":"2017/02/04/031-Time-complexity-notations/","link":"","permalink":"https://huklee.github.io/2017/02/04/031-Time-complexity-notations/","excerpt":"","text":"Time complexity notationsSometimes complexed about the exact meaning of the Big-O, theta, and omega notations. I found a great and beautiful summary table of them. For more details, check out the wikipedia pages below. UsefulAlgorithm Time complexity : Family of Bachman Landau notations","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/tags/algorithm/"}]},{"title":"Master theorem","slug":"016-Master-theorem","date":"2017-02-04T07:34:57.000Z","updated":"2017-02-05T06:11:30.000Z","comments":true,"path":"2017/02/04/016-Master-theorem/","link":"","permalink":"https://huklee.github.io/2017/02/04/016-Master-theorem/","excerpt":"","text":"Master theoremrecursive algorithm을 구현할 때, 점화식으로부터 시간 복잡도를 구할 때 사용되는 theorem이다. 기본적으로 점화식이 다음과 같이 나올 경우에 대해서, 다음 세 가지 usecase 로 나누어서 해당 algorithm의 time complexity를 측정하는 것이 가능하다. Example유명하게 알려져 있는 recursive algorithm에 Master theorem을 대입하면 다음과 같다. further questions 각각 다음과 같은 식으로 점화식이 분리가 되어서 나올 때는 어떻게 식을 적용해야 하는 지는 좀 헷갈린다. T(n) = T(0.4n) + T(0.6n) + O(n) T(n) = T(0.4n) + T(0.2n) + O(n^2) Userful linksMaster theorem, Wikipedia","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/tags/algorithm/"}]},{"title":"Tips on tech interviews by Gayle Mac","slug":"030.Summay_Hackerrank_Gayle_Mc","date":"2017-02-01T14:08:35.000Z","updated":"2017-02-01T14:14:50.000Z","comments":true,"path":"2017/02/01/030.Summay_Hackerrank_Gayle_Mc/","link":"","permalink":"https://huklee.github.io/2017/02/01/030.Summay_Hackerrank_Gayle_Mc/","excerpt":"","text":"Tips on tech interviews by Gayle Mac1. how companies evaluate tech interviews you gotta focus on communications Talk a lot loud to express thought process At least, try to summarize what you try to do little mumbles are better than staying silent 2. how to approach behavioral questions short intro quick shows of success key strories (let the interview ask for details) hobbies (tech / non-tech) prepare to dicuss at least 2-3 projects in detail techinial role soft skills about the bad stuff mistakes failures 3. 7 steps to solve algorithm problems listen example brute force optimize walk through your algorithm code on a writeboard or on a paper coding style matters consistnet braces descriptive variables modulize test analyse use test cases 4. 3 algorithm strategies BUD Bottlenecks what details make the algorithm slow? how can we improve that? Unneccessary work is there any unneccessary work to make the algo faster? Duplicated work same with the above Space / Time trade-offs Hashtable : good example of space/time trade-offs DIY Use your brain to find a shortcut algorithm Try a large &amp; generic example Useful LinksHow companies evaluate tech interviews - Gayle Mc How to approach behavioral questions - Gayle Mc 7 Step to solve algorithm problems - Gayle Mc 3 Algorithm Strategies - Gayle Mc","categories":[{"name":"Tips","slug":"Tips","permalink":"https://huklee.github.io/categories/Tips/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"https://huklee.github.io/tags/Tips/"}]},{"title":"Tips using linux","slug":"029.Linux+Tips","date":"2017-02-01T13:33:35.000Z","updated":"2017-02-11T05:19:51.000Z","comments":true,"path":"2017/02/01/029.Linux+Tips/","link":"","permalink":"https://huklee.github.io/2017/02/01/029.Linux+Tips/","excerpt":"","text":"Tips using linuxUpload &amp; download files using SCP local sever -&gt; remote server 1scp abc@111.222.333.444:/home/abc/* /home/me/ remote sever -&gt; local server 1scp /home/me/ abc@111.222.333.444:/home/abc/* in case of using other port as SSH 1scp -P 2222 abc@1.2.3.4:/home/abc/* /home/me/ List all files including folders 1find . excluding folders 1find . -type f 다른 계정으로 bash 명령 실행하기 계정 이름, host 주소만 필요할 경우 1ssh [id]@[host] [command] password도 필요한 경우 1sshpass -p [password] ssh [id]@[host] [command] bash error handling error 발생시 스크립트 종료하기 1[bash_command] || [error_handling_function] example 12345678function error_exit&#123; echo \"$1\" 1&gt;&amp;2 exit 1&#125;# [bash_command] || error_exit [error_message]cd $some_directory || error_exit \"Cannot change directory! Aborting.\" Using bash script on python simple way without a return value 12import os, sysos.system(\"ls -al\") the way with a return value (printed value) 123456import subprocessdef bashcmd (cmd, isPrint=True): result = subprocess.check_output(cmd, shell=True) print result.decode(\"utf-8\")bashcmd ('ls -al') in case of python &lt; 2.7 import subprocess if \"check_output\" not in dir( subprocess ): # duck punch it in! def f(*popenargs, **kwargs): if 'stdout' in kwargs: raise ValueError('stdout argument not allowed, it will be overridden.') process = subprocess.Popen(stdout=subprocess.PIPE, *popenargs, **kwargs) output, unused_err = process.communicate() retcode = process.poll() if retcode: cmd = kwargs.get(\"args\") if cmd is None: cmd = popenargs[0] raise subprocess.CalledProcessError(retcode, cmd) return output subprocess.check_output = f def bashcmd (cmd, isPrint=True): result = subprocess.check_output(cmd, shell=True) print result.decode(\"utf-8\") bashcmd ('ls -al') Useful Linksfile upload &amp; download between Linux machines using scp python 사용하여 bash shell 사용 how to use subprocess.check_output() in python 2.6 다른 계정으로 명령 실행하기 using ssh with password error handling with bash","categories":[{"name":"Tips","slug":"Tips","permalink":"https://huklee.github.io/categories/Tips/"},{"name":"Linux","slug":"Tips/Linux","permalink":"https://huklee.github.io/categories/Tips/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://huklee.github.io/tags/Linux/"}]},{"title":"Install R & Rstudio in CLI on Mac","slug":"028.Install-R-Rstudio-in-CLI","date":"2017-01-31T14:33:35.000Z","updated":"2017-01-31T14:49:01.000Z","comments":true,"path":"2017/01/31/028.Install-R-Rstudio-in-CLI/","link":"","permalink":"https://huklee.github.io/2017/01/31/028.Install-R-Rstudio-in-CLI/","excerpt":"","text":"Install R &amp; Rstudio in CLI on MacInstall homebrewHomebrew is awesome, since you can just install things wtih your terminal, like yum, apt-get in Ubuntu. First, turn on your terminal. If you didn’t install homebrew yet, just copy &amp; paste the following script. 1ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" or you already installed homebrew, just update it. 1brew update &amp;&amp; brew upgrade Install R &amp; RstudioYou gotta extend the respositories by installing Cask. Just don’t be cared, follow the steps of each line. 12345678910brew tap caskroom/caskbrew install brew-caskbrew install Caskroom/cask/xquartzbrew cask install javabrew tap homebrew/sciencebrew install Rbrew install Caskroom/cask/rstudio Then, you can get this. note While you got into several steps, it would bootstrap. It could take more than an hour sometimes. Don’t be panic, and take a cup of coffee reading some posts in Facebook or some. Useful linksR for Mac Rstudio for Mac How to install R &amp; Rstudio Shiny in Rstudio","categories":[{"name":"Data Science","slug":"Data-Science","permalink":"https://huklee.github.io/categories/Data-Science/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://huklee.github.io/tags/Mac/"},{"name":"R","slug":"R","permalink":"https://huklee.github.io/tags/R/"},{"name":"brew","slug":"brew","permalink":"https://huklee.github.io/tags/brew/"}]},{"title":"Cracking the coding interview summary","slug":"027.Cracking the coding interview summary","date":"2017-01-29T17:22:38.000Z","updated":"2017-02-04T07:37:09.000Z","comments":true,"path":"2017/01/30/027.Cracking the coding interview summary/","link":"","permalink":"https://huklee.github.io/2017/01/30/027.Cracking the coding interview summary/","excerpt":"","text":"Important Data Structure array &amp; string linked Lists stack &amp; queue tree &amp; graph Important algorithms &amp; concepts bit manipulations probabilities OOP Recursive &amp; Dynamic Programming Sort &amp; Search Scalability &amp; memory issues Testing Knowledge C++ database thread &amp; lock Data Structure termsTree Tree = acyclic graph Binary tree = tree that consists of 2-children nodes Binary Search Tree = binary tree with the relationship between all parent(p) and left child(l), right child(r), such that l.val &lt;= p.val &lt; r.val Depth Min : logn // Max : n Search Best : O(logn) // Wost : O(n) Traverse pre-order : parent -&gt; left subtree -&gt; right subtree in-order : left subtree -&gt; parent -&gt; right subtree post-order : left subtree -&gt; right subtree -&gt; parent Balanced BST Red-Black Tree AVL Tree Treap : tree + heap, randomized binary search tree implementation node implementation Array vs Dynamic memory Useful LinksTree Data structure Binary Tree BST","categories":[{"name":"Tips","slug":"Tips","permalink":"https://huklee.github.io/categories/Tips/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/tags/algorithm/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"https://huklee.github.io/tags/Data-Structure/"}]},{"title":"my vim cheat sheet","slug":"026.my-vim-cheat-sheet","date":"2017-01-29T11:05:32.000Z","updated":"2017-01-29T15:38:58.000Z","comments":true,"path":"2017/01/29/026.my-vim-cheat-sheet/","link":"","permalink":"https://huklee.github.io/2017/01/29/026.my-vim-cheat-sheet/","excerpt":"","text":"Huklee’s Vim cheet sheet1. Using bash shell commands 1:! [bash_cmd] run a shell1:sh 2. Auto-indent all lines 1gg=G for selected lines 12[selected mode]= 3.Useful LinksVim tips working external commands vim cheat sheet","categories":[{"name":"Tips","slug":"Tips","permalink":"https://huklee.github.io/categories/Tips/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://huklee.github.io/tags/vim/"}]},{"title":"Binary search problem","slug":"023.Binary-search-problem","date":"2017-01-27T16:25:57.000Z","updated":"2017-01-27T16:34:18.000Z","comments":true,"path":"2017/01/28/023.Binary-search-problem/","link":"","permalink":"https://huklee.github.io/2017/01/28/023.Binary-search-problem/","excerpt":"","text":"1. Bianry Search for closest number problem Input : ordred list of integers, a given number Ouptut : find the the closest number to the given number solution in python 123456789101112131415# recursion solutiondef solve(arr, num, start=0): # 01. base case : size() &lt;= 3 if len(arr) &lt;= 3: minVal = min([abs(x - num) for x in arr]) for i in range(len(arr)): if minVal == abs(arr[i] - num): return start + i # 02. check the mid value then exclude the wrong side mid = int(len(arr)/2) if arr[mid] &lt; num: return solve(arr[mid + 1:], num, start + mid + 1) else: return solve(arr[:mid + 1], num, start) solution in C++ 12345678910111213141516171819// recursive solutionint solve(vector&lt;int&gt; arr, int num, int start, int end)&#123; // 01. base case : size() &lt;= 3 if (end - start &lt;= 2)&#123; int min_val = abs(num - arr[start]); for (int i=start; i &lt;= end; i++) min_val = min(abs(num - arr[i]), min_val); for (int i=start; i &lt;= end; i++) if min_val == abs(num - arr[i]) return i; &#125; // 02. check the mid value then exclude the wrong side int mid = (end - start)/2; if (arr[mid] &lt; num) return solve(arr, num, mid + 1, end); else return solve(arr, num, start, mid);&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/tags/algorithm/"}]},{"title":"SQL tutorials","slug":"022.SQL-tutorials","date":"2017-01-27T16:14:18.000Z","updated":"2017-01-27T16:25:31.000Z","comments":true,"path":"2017/01/28/022.SQL-tutorials/","link":"","permalink":"https://huklee.github.io/2017/01/28/022.SQL-tutorials/","excerpt":"","text":"SQL : Structured Query Language SQL tutorialsDB를 다루는 데 기본적인 query를 배우기 위해서는 SQL을 알아야 한다. 어느 정도 사용법을 익숙해 지기 위해서는 다음 튜토리얼을 따라가면 금방 익힐 수 있다. SQL Tutorials 사이트에서는 간단한 SQL Testbed를 제공하는데, 훌륭한 예제 database가 들어가 있어서, 왠만한 기본 기능을 익히고 테스트 하는 데 괜찮다. crate table &amp; insert into를 사용하면 데이터를 넣는 것도 가능하지 때문에, 이것저것 스스로 예제를 만들어서 간단히 테스트하는 것도 가능하다. SQL try testbed Advanced다음은 개인적으로 사용법이 좀 헷갈리는 것들을 정리해 놓은 것 Group By12345678910SELECT orderid, SUM(total) as total_price, AVG(total)/SUM(quantity) as average_price_of_items, SUM(quantity) as ItemsFROM( SELECT *, quantity*price as total FROM [orderdetails] as o LEFT JOIN [products] as p WHERE o.productID = p.productID)GROUP BY orderid; =&gt; orderid 별로 total_price, average_price_of item, num_items를 구하는 SQL Query Useful Linksmysql installation on Mac Using database indexes SQL cheet Sheet","categories":[{"name":"database","slug":"database","permalink":"https://huklee.github.io/categories/database/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://huklee.github.io/tags/SQL/"},{"name":"database","slug":"database","permalink":"https://huklee.github.io/tags/database/"}]},{"title":"SQL all kinds of join queries","slug":"021.SQL-all-kinds-of-join-queries","date":"2017-01-27T16:01:45.000Z","updated":"2017-01-27T16:13:45.000Z","comments":true,"path":"2017/01/28/021.SQL-all-kinds-of-join-queries/","link":"","permalink":"https://huklee.github.io/2017/01/28/021.SQL-all-kinds-of-join-queries/","excerpt":"","text":"All kinds of SQL QueriesType 1: INNER JOIN - only where both tables match1.) INNER JOIN aka JOIN 123SELECT *FROM table1 as a (INNER) JOIN table2 as bON a.id = b.id; Type 2: OUTER JOINS where either one or both tables match1.) LEFT OUTER JOIN aka LEFT JOIN 123SELECT *FROM table1 as a LEFT (OUTER) JOIN table2 as bON a.id = b.id; 2.) RIGHT OUTER JOIN aka RIGHT JOIN 123SELECT *FROM table1 as a RIGHT (OUTER) JOIN table2 as bON a.id = b.id; 3.) FULL OUTER JOIN aka FULL JOIN (supported depending on what database program) 123SELECT *FROM table1 as a FULL OUTER JOIN table2 as bON a.id = b.id; Type 3: CROSS JOIN - Cartesian product(all possible combos of each table) (supported depending on what database program) 12SELECT *FROM table1 as a CROSS JOIN table2 as b; Useful Linksstackoverflow on SQL Cross Join &amp; Self Join","categories":[{"name":"database","slug":"database","permalink":"https://huklee.github.io/categories/database/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://huklee.github.io/tags/SQL/"},{"name":"database","slug":"database","permalink":"https://huklee.github.io/tags/database/"}]},{"title":"counting millisec time in bash on Mac","slug":"020.counting-millisec-time-in-bash-on-Mac","date":"2017-01-22T06:02:25.000Z","updated":"2017-02-11T05:20:38.000Z","comments":true,"path":"2017/01/22/020.counting-millisec-time-in-bash-on-Mac/","link":"","permalink":"https://huklee.github.io/2017/01/22/020.counting-millisec-time-in-bash-on-Mac/","excerpt":"","text":"Counting time with accuracy of milliseconds in bash on MacCounting time with accuracy of milliseconds in normal bashbash에서 프로그램을 실행시켜서 실행시간을 재는 간단한 bash script는 아래와 같다. milliseconds 단위로 실행시간을 측정할 수 있다. 123456789101112131415161718# countTime.sh#!/bin/bashargc=$#if [ $argc -eq 0 ]; then echo \"usage ./countTime.sh program_to_run\" exitfi# check the beginning timebeginTime=$(date +%s%N)# runt the first parameterseval $1endTime=$(date +%s%N)elapsed=`echo \"($endTime - $beginTime) / 1000000\" | bc`elapsedSec=`echo \"scale=6;$elapsed / 1000\" | bc | awk '&#123;printf \"%.6f\", $1&#125;'`echo TOTAL: $elapsedSec sec on BSD, the default linux type of Mac문제는 BSD linux 에서는 기본적으로 date가 milliseconds기록을 기본적으로 지원하지 않는다. 그래서 기본적으로 아래와 같은 결과가 나온다. 12$ date +%s.%N1485066528.N 따라서 coreutils라는 패키지를 깔아서 gdate로 사용해야 한다. 설치 방법은 아래를 참조하자. brew는 기본적으로 설치되었다고 가정한다. 1brew install coreutils 다음은 bash의 alias로 date를 gdate로 바꿔준다. 1vim ~/.bash_profile 아래 내용을 추가하자. alias date=’/usr/local/bin/gdate’ 그러면 이제 date +%s.N을 했을 떄 제대로 나오는 것을 확인할 수 있다! 위에서 만든 스크립트도 제대로 사용이 가능하다. 12$ date +%s.%N1485066528.720920000 Useful Links경과시간 출력하기 counting time on Mac bash","categories":[{"name":"Tips","slug":"Tips","permalink":"https://huklee.github.io/categories/Tips/"},{"name":"Mac","slug":"Tips/Mac","permalink":"https://huklee.github.io/categories/Tips/Mac/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://huklee.github.io/tags/Mac/"},{"name":"bash","slug":"bash","permalink":"https://huklee.github.io/tags/bash/"},{"name":"Linux","slug":"Linux","permalink":"https://huklee.github.io/tags/Linux/"}]},{"title":"markdown cheat sheet","slug":"019.markdown-cheat-sheet","date":"2017-01-21T13:39:46.000Z","updated":"2017-01-21T14:02:36.000Z","comments":true,"path":"2017/01/21/019.markdown-cheat-sheet/","link":"","permalink":"https://huklee.github.io/2017/01/21/019.markdown-cheat-sheet/","excerpt":"","text":"1. Headers123456# H1## H2### H3#### H4##### H5###### H6 H1H2H3H4H5H62. Blockquotes123456&gt; Blockquotes are very handy in email to emulate reply text.&gt; This line is part of the same quote.Quote break.&gt; This is a very long line that will still be quoted properly when it wraps. Oh boy let&apos;s keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can *put* **Markdown** into a blockquote. Blockquotes are very handy in email to emulate reply text.This line is part of the same quote. Quote break. This is a very long line that will still be quoted properly when it wraps. Oh boy let’s keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can put Markdown into a blockquote. 3. Tables123456789101112| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 |There must be at least 3 dashes separating each header cell. The outer pipes (|) are optional, and you don&apos;t need to make the raw Markdown line up prettily. You can also use inline Markdown.Markdown | Less | Pretty--- | --- | ---*Still* | `renders` | **nicely**1 | 2 | 3 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 There must be at least 3 dashes separating each header cell. The outer pipes (|) are optional, and you don’t need to make the raw Markdown line up prettily. You can also use inline Markdown. Markdown Less Pretty Still renders nicely 1 2 3 Useful LinksGithub markdown cheat sheet","categories":[],"tags":[]},{"title":"algospot_traversal","slug":"018.algospot-traversal","date":"2017-01-21T10:27:20.000Z","updated":"2017-01-29T15:33:47.000Z","comments":true,"path":"2017/01/21/018.algospot-traversal/","link":"","permalink":"https://huklee.github.io/2017/01/21/018.algospot-traversal/","excerpt":"","text":"Algospot Traversalarray의 start, end 포인트만을 사용한 풀이12345678910111213141516171819202122232425262728293031323334353637383940414243// TRAVERSALint preTree[N_MAX];int inTree[N_MAX];int postTree[N_MAX];void guessPostTree(int preS, int preE, int inS, int inE, int postS, int postE)&#123; if (postS &gt; postE) return; // Initial Case int root; for (root = inS; root &lt;= inE; root++)&#123; if (preTree[preS] == inTree[root]) break; &#125; postTree[postE] = inTree[root]; // Recursive int leftLen = root - inS; guessPostTree(preS + 1, preS + leftLen, inS, root - 1, postS, postS + leftLen - 1); // Left guessPostTree(preS + leftLen + 1, preE, root + 1, inE, postS + leftLen, postE - 1); // Right cout &lt;&lt; inTree[root] &lt;&lt; \" \";&#125;int main()&#123; int T, N, i, j; cin &gt;&gt; T; for (int tc = 0; tc &lt; T; tc++)&#123; cin &gt;&gt; N; for (i = 0; i &lt; N; i++) cin &gt;&gt; preTree[i]; for (i = 0; i &lt; N; i++) cin &gt;&gt; inTree[i]; vector&lt;int&gt; v1(preTree, preTree + N); vector&lt;int&gt; v2(inTree, inTree + N); guessPostTree(0, N - 1, 0, N - 1, 0, N - 1); cout &lt;&lt; endl; &#125; return 0;&#125; slice()를 이용한 깔끔한 vector를 주고 받는 풀이12345678910111213141516171819202122232425262728293031323334353637vector&lt;int&gt; slice(const vector&lt;int&gt;&amp; v, int a, int b)&#123; return vector&lt;int&gt;(v.begin() + a, v.begin() + b);&#125;void guessPostTree(const vector&lt;int&gt;&amp; preorder, const vector&lt;int&gt;&amp; inorder)&#123; // 00. exit condition if (preorder.empty()) return; // 01. find the root and the pos of the root int N = preorder.size(); int root = preorder[0]; int leftLen = find(inorder.begin(), inorder.end(), root) - inorder.begin(); // 02. print the left &amp; right trees, then the root guessPostTree(slice(preorder, 1, leftLen + 1), slice(inorder, 0, leftLen)); // left sub-tree guessPostTree(slice(preorder, leftLen + 1, N), slice(inorder, leftLen + 1, N)); // right sub-tree cout &lt;&lt; root &lt;&lt; \" \";&#125;int main()&#123; int T, N, i, j; cin &gt;&gt; T; for (int tc = 0; tc &lt; T; tc++)&#123; cin &gt;&gt; N; for (i = 0; i &lt; N; i++) cin &gt;&gt; preTree[i]; for (i = 0; i &lt; N; i++) cin &gt;&gt; inTree[i]; vector&lt;int&gt; v1(preTree, preTree + N); vector&lt;int&gt; v2(inTree, inTree + N); guessPostTree(v1, v2); cout &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/categories/algorithm/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://huklee.github.io/tags/C/"},{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/tags/algorithm/"},{"name":"Tree","slug":"Tree","permalink":"https://huklee.github.io/tags/Tree/"},{"name":"Algospot","slug":"Algospot","permalink":"https://huklee.github.io/tags/Algospot/"}]},{"title":"intro to design patterns","slug":"017.intro-to-design-patterns","date":"2017-01-20T17:29:58.000Z","updated":"2017-02-11T01:40:28.000Z","comments":true,"path":"2017/01/21/017.intro-to-design-patterns/","link":"","permalink":"https://huklee.github.io/2017/01/21/017.intro-to-design-patterns/","excerpt":"","text":"Design patterns가장 유명한 디자인 패턴으로는 GoF Design pattern이 있다. 하도 유명해서 필수로 알아두면 좋을 패턴들은 다음과 같다. Creational patterns Abstract factory pattern groups object factories that have a common theme. Builder pattern constructs complex objects by separating construction and representation. Factory method pattern creates objects without specifying the exact class to create. Prototype pattern creates objects by cloning an existing object. Singleton pattern restricts object creation for a class to only one instance. implementation in c++ Structural patterns Adapter allows classes with incompatible interfaces to work together by wrapping its own interface around that of an already existing class. Bridge decouples an abstraction from its implementation so that the two can vary independently. Composite composes zero-or-more similar objects so that they can be manipulated as one object. Decorator dynamically adds/overrides behavior in an existing method of an object. ex&gt; java.io.bufferedinputstream Facade provides a simplified interface to a large body of code. Flyweight reduces the cost of creating and manipulating a large number of similar objects. Proxy provides a placeholder for another object to control access, reduce cost, and reduce complexity. Behavioral patterns Chain of responsibility delegates commands to a chain of processing objects. Command creates objects which encapsulate actions and parameters. Interpreter implements a specialized language.Iterator accesses the elements of an object sequentially without exposing its underlying representation. Mediator allows loose coupling between classes by being the only class that has detailed knowledge of their methods. Memento provides the ability to restore an object to its previous state (undo). Observer is a publish/subscribe pattern which allows a number of observer objects to see an event. ex&gt; java.swing / [c#]winform State allows an object to alter its behavior when its internal state changes. Strategy allows one of a family of algorithms to be selected on-the-fly at runtime. Template method defines the skeleton of an algorithm as an abstract class, allowing its subclasses to provide concrete behavior. Visitor separates an algorithm from an object structure by moving the hierarchy of methods into one object. etc MVC design patterns MVC : Model, View, Controller의 앞글자를 딴 것을 의미며, 어플리케이션의 역할을 세 가지로 구분한 개발 방법론이다. 핵심은 사용자가 직접 Model을 만지지 않도록 하는 구조라고 볼 수 있다. 아래처럼 사용자가 Controller를 조작하면, Controller가 Model을 통해서 데이터를 가져오고 그 정보를 바탕으로 View를 통해서 사용자에게 정보를 제공하는 구조이다. 추가로 비슷한 디자인 패턴 구조로는 MVP (Model, View, Presenter), MVVM (Model, View, View Model)가 있다. 두 모델은 View와 Model을 분리해 주는 장점을 가지고 있다. MVVM에서는 View가 보는 Data는 Model의 원래 정보가 아닌 View Model을 통해 간접적으로 얻는 Data이며, event를 통해서 view model의 변화를 Control하는 특징이 있다. GoF 패턴의 Observer 패턴과 연관성이 매우 크다. 객체의 상태변화, event, call-back function 등의 특성이 observer 패턴의 핵심 구성요소이기 때문이다. useful linksMVC, MVP, MVVM 차이점 Design pattern examples from non-program Design patterns Design patterns in source making","categories":[{"name":"programming","slug":"programming","permalink":"https://huklee.github.io/categories/programming/"}],"tags":[{"name":"design patterns","slug":"design-patterns","permalink":"https://huklee.github.io/tags/design-patterns/"}]},{"title":"How to use C++ STL well?","slug":"015.How-to-use-C-STL-well","date":"2017-01-19T14:09:34.000Z","updated":"2017-02-01T14:48:39.000Z","comments":true,"path":"2017/01/19/015.How-to-use-C-STL-well/","link":"","permalink":"https://huklee.github.io/2017/01/19/015.How-to-use-C-STL-well/","excerpt":"","text":"Usage examplestd::list1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;list&gt;void std_list_test()&#123; std::list&lt;int&gt; li; li.push_back(2); li.push_back(3); li.push_front(1); li.push_front(0); // 01. simple fore statement std::cout &lt;&lt; \"BEFORE\" &lt;&lt; std::endl; for(int i : li) std::cout &lt;&lt; i &lt;&lt; std::endl; // 02. insert for(std::list&lt;int&gt;::iterator ii=li.begin(); ii != li.end(); ii++) li.insert(ii, *ii); // 03. erase the node for(std::list&lt;int&gt;::iterator ii=li.begin(); ii != li.end(); ii++) if (*ii == 2) li.erase(ii); // 04. remove all nodes those have the value li.remove(1); // confirm the result std::cout &lt;&lt; \"AFTER\" &lt;&lt; std::endl; for(int i : li) std::cout &lt;&lt; i &lt;&lt; std::endl; // 05. clear the data of the list li.clear();&#125;int main()&#123; std_list_test(); return 0;&#125; std::vector123456789101112131415161718192021222324252627282930313233343536void std_vector_test()&#123; std::cout &lt;&lt; \"============================= std::vector Test ===================================\" &lt;&lt; std::endl; // 01. assignemnt std::vector&lt;int&gt; v1; v1.reserve(20); // assign the memory space of 20 * int std::vector&lt;int&gt; v2(2); // assign the memory &amp; fill 2*null(0) // 02. stack operation v1.push_back(1); v1.push_back(2); v1.push_back(3); v1.pop_back(); v2.push_back(10); v2.push_back(20); // 03. access for(int i : v1) std::cout &lt;&lt; i &lt;&lt; \" \"; std::cout &lt;&lt; std::endl; // 04. insert operation v1.insert(vi.begin() + 1, 4); v1.insert(v1.begin(), v2.begin(), v2.end()); for(int i : v1) std::cout &lt;&lt; i &lt;&lt; \" \"; std::cout &lt;&lt; std::endl; // 05. copy from array, vector int arr[] = &#123;1,2,3,4&#125;; std::vector&lt;int&gt; v3(arr, arr + sizeof(arr)/sizeof(int)); std::vector&lt;int&gt; v4(v3); for(int i : v3) std::cout &lt;&lt; i &lt;&lt; \" \"; std::cout &lt;&lt; std::endl; for(int i : v4) std::cout &lt;&lt; i &lt;&lt; \" \"; std::cout &lt;&lt; std::endl; // 06. clear the data v1.clear(); v2.clear(); v3.clear(); v4.clear();&#125; std::unordered_map following should be complied by more than c++11. 1$ g++ -std=c++11 main.cpp the example code is following 1234567891011121314151617181920212223#include &lt;unordered_map&gt;void std_unorderedmap_test()&#123; // 01. initialization &amp; list all elements in it std::unordered_map&lt;std::string, std::string&gt; mymap; mymap = &#123;&#123;\"USA\",\"D.C\"&#125;, &#123;\"KO\", \"Seoul\"&#125;, &#123;\"Japan\", \"Tokyo\"&#125;&#125;; std::cout &lt;&lt; \"mymap contains:\"; for (auto it = mymap.begin(); it != mymap.end(); it++)&#123; std::cout &lt;&lt; \" \" &lt;&lt; it-&gt;first &lt;&lt; \":\" &lt;&lt; it-&gt;second; // it-&gt;first = key, it-&gt;second = value &#125; std::cout &lt;&lt; std::endl; // 02. how to use it in general way std::unordered_map&lt;int, int&gt; ht; ht[1] = 10; ht[2] = 20; std::cout &lt;&lt; ht[1] &lt;&lt; std::endl; std::cout &lt;&lt; ht[2] &lt;&lt; std::endl; if (ht.find(3) == ht.end()) std::cout &lt;&lt; \"3 doesn't have the key in ht\" &lt;&lt; std::endl;&#125; Useful linksC++ 공부할 때 읽으면 좋을 책들 STL은 정말 괜찮은 물건인가? C++ 책 추천: 해외/번역서 기준 from SOF Effective STL_pdf C-Tutorial-A-Beginners-Guide-to-stdvector C++ std::vector reference C++ std::unordered_map","categories":[{"name":"Programming_Language","slug":"Programming-Language","permalink":"https://huklee.github.io/categories/Programming-Language/"},{"name":"C++","slug":"Programming-Language/C","permalink":"https://huklee.github.io/categories/Programming-Language/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://huklee.github.io/tags/C/"},{"name":"stl","slug":"stl","permalink":"https://huklee.github.io/tags/stl/"}]},{"title":"Things interesting","slug":"025.Things-interesting","date":"2017-01-18T00:08:31.000Z","updated":"2017-01-29T15:38:47.000Z","comments":true,"path":"2017/01/18/025.Things-interesting/","link":"","permalink":"https://huklee.github.io/2017/01/18/025.Things-interesting/","excerpt":"","text":"EducationMOOC Udacity / Intro do Big data Free / 2 Months Udacity / Intro to Hadoop and Mapreduce Free / 1 Month Coursera / Data Science specialization $49.00 USDper month / 3~6 months Coursera / Functional Programming in Scala specialization $395 USD / 4~5 months","categories":[{"name":"etc","slug":"etc","permalink":"https://huklee.github.io/categories/etc/"}],"tags":[{"name":"etc","slug":"etc","permalink":"https://huklee.github.io/tags/etc/"},{"name":"education","slug":"education","permalink":"https://huklee.github.io/tags/education/"}]},{"title":"manual for Node.js","slug":"024.manual-for-Node-js","date":"2017-01-17T14:20:40.000Z","updated":"2017-01-29T11:20:25.000Z","comments":true,"path":"2017/01/17/024.manual-for-Node-js/","link":"","permalink":"https://huklee.github.io/2017/01/17/024.manual-for-Node-js/","excerpt":"","text":"node.jsDesign Goal Function은 직접 플랫폼 I/O에 접속하지 않습니다. Disk, network, 프로세스를 통해 데이터를 받기 위해서는 대부분 콜백(callback)을 사용합니다. TCP, DNS, HTTP같은 프로토콜을 지원합니다. HTTP feature를 지원합니다.(Chunk된 requst/response, Keep-alive, Comet을 위한 리퀘스트 홀딩) Internal Design features Google의 V8 사용 Marc Lehmann이 만든 이벤트루프 라이브러리 libev 사용 linksnode.js 언어 디자인 측면에서의 분석 node.js 소개 및 내부구조에 관한 이론 node.js at jsconf 2009 node.js 튜토리얼","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://huklee.github.io/categories/Tutorial/"},{"name":"node.js","slug":"Tutorial/node-js","permalink":"https://huklee.github.io/categories/Tutorial/node-js/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://huklee.github.io/tags/javascript/"},{"name":"node.js","slug":"node-js","permalink":"https://huklee.github.io/tags/node-js/"},{"name":"usage","slug":"usage","permalink":"https://huklee.github.io/tags/usage/"}]},{"title":"Jupyter_usage","slug":"014.Jupyter-usage","date":"2017-01-17T14:19:38.000Z","updated":"2017-01-18T00:01:57.000Z","comments":true,"path":"2017/01/17/014.Jupyter-usage/","link":"","permalink":"https://huklee.github.io/2017/01/17/014.Jupyter-usage/","excerpt":"","text":"Jupyter UsageMarkdownMastering Markdown How to make tables Markdown Tutorial Basic writing and formatting syntax of Markdown Converting Table Data (excel, csv) into Markdown Table","categories":[{"name":"Programming_Language","slug":"Programming-Language","permalink":"https://huklee.github.io/categories/Programming-Language/"},{"name":"python","slug":"Programming-Language/python","permalink":"https://huklee.github.io/categories/Programming-Language/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://huklee.github.io/tags/python/"},{"name":"jupyter","slug":"jupyter","permalink":"https://huklee.github.io/tags/jupyter/"},{"name":"notebook","slug":"notebook","permalink":"https://huklee.github.io/tags/notebook/"},{"name":"usage","slug":"usage","permalink":"https://huklee.github.io/tags/usage/"}]},{"title":"how to start a wiki","slug":"013.how-to-start-a-wiki","date":"2017-01-17T14:18:28.000Z","updated":"2017-01-17T14:19:18.000Z","comments":true,"path":"2017/01/17/013.how-to-start-a-wiki/","link":"","permalink":"https://huklee.github.io/2017/01/17/013.how-to-start-a-wiki/","excerpt":"","text":"how to start a wikiPopular Wikis MediaWiki 가장 유명한 위키 프로그램. 위키하우, 위키피디아 등 많은 사이트에 사용된다. 다른 위키 사이트들 중에서 쓰는 사이트도 많다.[3] TikiWiki 두번째로 유명한 위키 프로그램. 많은 사이트에서 사용된다. 플러그인 지원이 좋아서 포럼, 이미지 갤러리, 달력 등의 기능을 쉽게 추가할 수 있다. UserPress 워드프레스용 위키 플러그인. MediaWiki와 다른 위키의 기능을 다 갖추고 있으며, 쓰기도 쉽다. DokuWiki 작지만 인기가 늘어가고 있는 위키 프로그램. 특히 회사들에서 많이 쓰인다. 팀이나 회사에서 협업을 위해 많이 쓰여며, 사용자 권한에 따라 접근할 수 있는 문서가 달라진다. linkshow to start a Mediawiki Mediawiki를 개인위키로 서비스하기 위키사이트 시작하기","categories":[{"name":"etc","slug":"etc","permalink":"https://huklee.github.io/categories/etc/"}],"tags":[{"name":"wiki","slug":"wiki","permalink":"https://huklee.github.io/tags/wiki/"}]},{"title":"How_to_install_Jupyter_Notebook_in_Ubuntu","slug":"012.How-to-install-Jupyter-Notebook-in-Ubuntu","date":"2017-01-17T14:16:12.000Z","updated":"2017-01-18T00:01:59.000Z","comments":true,"path":"2017/01/17/012.How-to-install-Jupyter-Notebook-in-Ubuntu/","link":"","permalink":"https://huklee.github.io/2017/01/17/012.How-to-install-Jupyter-Notebook-in-Ubuntu/","excerpt":"","text":"Ubuntu에 jupyter notebook 설치 및 웹프라우저로 원격접속 설정 설치환경 : linux (Ubuntu 14.04.1) 주의할 점jupyter가 개인용으로 만들어서 져서, 여러 명이 쓰기에는 부적절하긴 하다. 같은 파일을 동시에 고치거나 하면 서버가 다운될 확률이 다분하니, 굳이 여러 명이 써야할 경우에는 되도록 각자 작업할 수 있도록 하자. 여러 명이 안정적으로 사용하는 환경을 구축하고 싶다면 jupyterHub가 더 적절하니 이를 참고하자. 설치 순서 https://www.continuum.io/downloads#linux 에서 최선 Anaconda download winSCP를 사용하여 설치파일 전송 (/tmp/Anaconda3-4.2.0-Linux-x86_64.sh) putty로 접속하여 해당 파일 실행하여 설치 (bash /tmp/Anaconda3-4.2.0-Linux-x86_64.sh) yes 혹은 엔터로 쭉쭉 진행 설치 후 재부팅 (reboot) jupyter notebook –generate-config 실행 mkdir /usr/jupyter 실행 (jupyter notebook의 root폴더 생성) vim /root/.jupyter/jupyter_notebook_config.py 하여 해당 내용 맨 아랫줄에 추가 123c = get_config()c.NotebookApp.ip = '10.240.35.100' # ip address of the serverc.NotebookApp.port = 8080c.FileContentsManager.root_dir = '/usr/jupyter/' vim /etc/init.d/jupyter 실행, 아래 내용 적고 저장 1jupyter notebook chmod 755 /etc/init.d/jupyter cd /etc/init.d sudo update-rc.d /etc/init.d/jupyter defaults 다시 재부팅 (reboot) 보안 키 설정하기위의 설정대로만 하면 jupyter notebook 접속 시 보안키가 전혀 필요하지 않다. 반면에 비밀번호를 설정해서 보안을 조금 강화하고 싶다면 아래와 같이 설정을 추가하면 된다. hash key 만들기 ipython을 실행하여 아래 명령을 수행하자. 1$ ipython 12from notebook.auth import passwdpasswd() 적당한 password를 두 번 치면 아래와 같이 hashed password를 얻을 수 있다. 123Enter password:Verify password:Out[2]: &apos;sha1:67c9e60bb8b6:9ffede0825894254b2e042ea597d771089e11aed&apos; SSL 사용 설정 SSL을 이용하면 브라우저에서 패스워드가 암호화되서 보내지기 때문에 보안이 훨씬 좋아진다. 이를 위해서 self-signed certificate를 생성 하자. OpenSSL을 이용해서 certificate을 생성할 수 있다. 유효기간은 365일이다. 1openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout mycert.pem -out mycert.pem jupyter_notebook_config.py 에 password 추가 추가할 내용은 아래와 같다. password에는 1.에서 얻은 hashed password를 그대로 넣으면 되며, certiflie에는 2.에서 생성한 .pem 파일을 지정하여 집어넣자. path는 임의대로 넣었으니 자신이 지정한 폴더명을 사용하여 진행하자. 12c.NotebookApp.password = u'sha1:67c9e60bb8b6:9ffede0825894254b2e042ea597d771089e11aed'c.NotebookApp.certfile = u'/absolute/path/to/your/certificate/mycert.pem' 끝. Useful Linkshttps://www.continuum.io/downloads#linux http://jupyter-notebook.readthedocs.io/en/latest/public_server.html http://goodtogreate.tistory.com/entry/IPython-Notebook-%EC%84%A4%EC%B9%98%EB%B0%A9%EB%B2%95 http://www.whatwant.com/497 Jupyterhub를 이용하여 Jupyter Notebook 실습 환경 구축하기","categories":[],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://huklee.github.io/tags/Ubuntu/"},{"name":"python","slug":"python","permalink":"https://huklee.github.io/tags/python/"},{"name":"jupyter","slug":"jupyter","permalink":"https://huklee.github.io/tags/jupyter/"},{"name":"notebook","slug":"notebook","permalink":"https://huklee.github.io/tags/notebook/"}]},{"title":"how to gdb on mac","slug":"011.how-to-gdb-on-mac","date":"2017-01-13T15:11:05.000Z","updated":"2017-01-18T00:02:00.000Z","comments":true,"path":"2017/01/14/011.how-to-gdb-on-mac/","link":"","permalink":"https://huklee.github.io/2017/01/14/011.how-to-gdb-on-mac/","excerpt":"","text":"How to gdb on MacSadly, gdb is not built-in package for Mac. On Mac, the easiest way to install a package working mainly in CLI such as gdb, gcc, g++, and etc, is to use Brew (Homebrew). 1ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" then, use the brew to install the gdb package. 1brew install gdb ➜ algorithms git:(master) ✗ brew install gdbUpdating Homebrew…==&gt; Downloading https://homebrew.bintray.com/bottles/gdb-7.12_1.el_capitan.bottle.tar.gz ######################################################################## 100.0%==&gt; Pouring gdb-7.12_1.el_capitan.bottle.tar.gz==&gt; Caveatsgdb requires special privileges to access Mach ports.You will need to codesign the binary. For instructions, see: https://sourceware.org/gdb/wiki/BuildingOnDarwin On 10.12 (Sierra) or later with SIP, you need to run this: echo “set startup-with-shell off” &gt;&gt; ~/.gdbinit==&gt; Summary🍺 /usr/local/Cellar/gdb/7.12_1: 49 files, 6.8M here goes the result! 1$ sudo gdb $ gdb GNU gdb (GDB) 7.12 Copyright (C) 2016 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &gt;http://gnu.org/licenses/gpl.html This is free software: you are free to change andredistribute &gt; it. There is NO WARRANTY, to the extent permitted by law. Type &gt; “show copying” and “show warranty” for details. This GDB was configured as “x86_64-apple-darwin15.6.0”. Type “show configuration” for configuration details. For bug reporting instructions, please see: http://www.gnu.org/software/gdb/bugs/. Find the GDB manual and other documentation resources online at: http://www.gnu.org/software/gdb/documentation/. For help, type “help”. Type “apropos word” to search for commands related to “word”. (gdb) So simple! Just remember that you should run gdb as the super user with “sudo” on mac.","categories":[{"name":"Tips","slug":"Tips","permalink":"https://huklee.github.io/categories/Tips/"},{"name":"Mac","slug":"Tips/Mac","permalink":"https://huklee.github.io/categories/Tips/Mac/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://huklee.github.io/tags/C/"},{"name":"Mac","slug":"Mac","permalink":"https://huklee.github.io/tags/Mac/"},{"name":"linux","slug":"linux","permalink":"https://huklee.github.io/tags/linux/"},{"name":"gdb","slug":"gdb","permalink":"https://huklee.github.io/tags/gdb/"}]},{"title":"gcc, g++, clang and LLVM","slug":"010.gcc-g-clang-and-LLVM","date":"2017-01-06T14:32:43.000Z","updated":"2017-01-18T00:02:01.000Z","comments":true,"path":"2017/01/06/010.gcc-g-clang-and-LLVM/","link":"","permalink":"https://huklee.github.io/2017/01/06/010.gcc-g-clang-and-LLVM/","excerpt":"","text":"How does g++ work with c++11 codes?Let’s say that we run a simple program which consists of following C++ codes.12345678910111213// test_noc++11.cpp#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int arr[] = &#123;1,2,3&#125;; vector&lt;int&gt; vi(arr, arr + sizeof(arr) / sizeof(arr[0])); for (vector&lt;int&gt;::iterator it=vi.begin(); it != vi.end(); it++)&#123; cout &lt;&lt; *it &lt;&lt; endl; &#125; return 0;&#125; when you build this cpp file, it works well with g++. 12345$ g++ test_noc++11.cpp$ ./a.out123 My question starts from here. What about c++11 codes? Does it work with my complier without any problem? So let me go for it. 12345678910111213// test_c++11.cpp#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int arr[] = &#123;1,2,3&#125;; vector&lt;int&gt; vi(arr, arr + sizeof(arr) / sizeof(arr[0])); for (const int&amp; data : vi)&#123; cout &lt;&lt; data &lt;&lt; endl; &#125; return 0;&#125; This code is using the “Range-based for loop” enhancement in C++11. When I tried to compile this, we can see the warning like following. 123456789$ g++ test.cpptest.cpp:9:23: warning: range-based for loop is a C++11 extension [-Wc++11-extensions] for (const int&amp; data : vi)&#123; ^1 warning generated.$ ./a.out123 It works anyway, what about the version of gcc then? 123456$ g++ --versionConfigured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/usr/include/c++/4.2.1Apple LLVM version 8.0.0 (clang-800.0.38)Target: x86_64-apple-darwin15.6.0Thread model: posixInstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin version Release Date GCC 4.2.2 October 7, 2007 GCC 4.2.1 July 18, 2007 GCC 4.2.0 May 13, 2007 the version of gcc is indeed 4.2.1, which doesn’t support C++11 since it’s developed in 2007. What are clang and LLVM?So what makes my code work? What are clang and LLVM? Let’s go a little deeper. Clang /ˈklæŋ/[4] is a compiler front end for the programming languages C, C++, Objective-C, Objective-C++, OpenMP,[5] OpenCL, and CUDA. It uses LLVM as its back end and has been part of the LLVM release cycle since LLVM 2.6. from Wikipedia The LLVM compiler infrastructure project (formerly Low Level Virtual Machine) is a “collection of modular and reusable compiler and toolchain technologies” used to develop compiler front ends and back ends.LLVM is written in C++ and is designed for compile-time, link-time, run-time, and “idle-time” optimization of programs written in arbitrary programming languages. Originally implemented for C and C++, the language-agnostic design of LLVM has since spawned a wide variety of front ends: languages with compilers that use LLVM include ActionScript, Ada, C#, Common Lisp, Crystal, D, Delphi, Fortran, OpenGL Shading Language, Halide, Haskell, Java bytecode, Julia, Lua, Objective-C, Pony, Python, R, Ruby, Rust, CUDA, Scala, and Swift. from Wikipedia All right. I just figured out when I run the g++, llvm-gcc is indeed running, which is the gcc frontend, and then the llvm backend. On the other side, clang++ is running clang, which is the clang frontend and then the llvm backend. Following So, my g++ is actually using clang-LLVM 8.0, which supports c++11, even c++14. DONE. Further questions what are front-end compiler and back-end complier? I should’ve taken the complier coursework during my B.S :( who made the clang &amp; LLVM? are they open-source projects? LinksC++11 WikipediaC++11 Tutorial VideoAdded featured in C++11 Slidegcc release noteclang project homepageclang Wikipedia[LLVM Wikipedia] (https://en.wikipedia.org/wiki/LLVM)g++, clang++ on mac","categories":[{"name":"Programming_Language","slug":"Programming-Language","permalink":"https://huklee.github.io/categories/Programming-Language/"},{"name":"C++","slug":"Programming-Language/C","permalink":"https://huklee.github.io/categories/Programming-Language/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://huklee.github.io/tags/C/"},{"name":"gcc","slug":"gcc","permalink":"https://huklee.github.io/tags/gcc/"},{"name":"g++","slug":"g","permalink":"https://huklee.github.io/tags/g/"},{"name":"clang","slug":"clang","permalink":"https://huklee.github.io/tags/clang/"},{"name":"LLVM","slug":"LLVM","permalink":"https://huklee.github.io/tags/LLVM/"},{"name":"compiler","slug":"compiler","permalink":"https://huklee.github.io/tags/compiler/"}]},{"title":"leetcode_two-sum","slug":"009.leetcode-two-sum","date":"2017-01-03T13:53:01.000Z","updated":"2017-01-21T10:31:50.000Z","comments":true,"path":"2017/01/03/009.leetcode-two-sum/","link":"","permalink":"https://huklee.github.io/2017/01/03/009.leetcode-two-sum/","excerpt":"","text":"leetcode problem solvinghttps://leetcode.com/problems/two-sum/ Brute-force solution : O(n^2)1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; // 1. O(n^2) solution // Brute-force : pick the two number; vector&lt;int&gt; answer = vector&lt;int&gt;(); for (int i=0; i &lt; nums.size(); i++)&#123; int pivot = nums[i]; for (int j=i + 1; j &lt; nums.size(); j++)&#123; int sum = pivot + nums[j]; if(sum == target)&#123; answer.push_back(i); answer.push_back(j); return answer; &#125; &#125; &#125; return answer; &#125;&#125; Hash table using solution : O(n)The key idea is the complement of an answer number must exist (an answer number + the complement number = target). So we just should minimize the time to find the complement number, which I found a hash table is the one. Search the complement number in the existing hash table, and if not found, add the number to the hash table.DONE 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; // 2. O(n) solution // using hash table unordered_map&lt;int, int&gt; hash_table; vector&lt;int&gt; answer = vector&lt;int&gt;(); for (int i=0; i &lt; nums.size(); i++)&#123; int complement = target - nums[i]; if (hash_table.find(complement) != hash_table.end())&#123; answer.push_back(hash_table[complement]); answer.push_back(i); return answer; &#125; hash_table[nums[i]] = i; &#125; return answer; &#125;&#125;;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/categories/algorithm/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://huklee.github.io/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://huklee.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/tags/algorithm/"},{"name":"array","slug":"array","permalink":"https://huklee.github.io/tags/array/"}]},{"title":"Objective-C Tutorials","slug":"008.Objective-C-Tutorials","date":"2017-01-01T08:27:52.000Z","updated":"2017-01-18T00:02:02.000Z","comments":true,"path":"2017/01/01/008.Objective-C-Tutorials/","link":"","permalink":"https://huklee.github.io/2017/01/01/008.Objective-C-Tutorials/","excerpt":"","text":"Objective-C Tutorial pages기본적인 Objective-C를 학습하는 데 있어서 필요한 튜토리얼들을 대충 정리해 보았다. Objective-C의 기본개념기본적인 Objective C의 문법과 개념에 대해서 다루고 있는 페이지다. Scott Stevenson의 Objective-C 튜토리얼을 번역한 글이다. 전체적으로 C에서 Objective-C가 어떤 부분에서 다르고, 실제 iOS 어플리케이션을 만들 때 어떤 부분들이 필요한지에 대해서 다루었다. 다만, 기초적인 Tutorial이라고 표현하기에 예제가 부족하고, 개념을 주로 설명하는 편이어서 Objective-C의 지식이 전무한 상태에서 따라가기에는 조금 안 좋아 보인다. 어느 정도 Objective-C의 개념을 훑어보기에 좋다. Objective-C 따라하기 강좌기초적인 예제 중심으로 Objective-C 프로그램을 개발하기에 필요한 부분들을 학습할 수 있는 Tutorial이다. 무작정 따라하기에는 쉽고, 빨리 따라할 수 있는 구성으로 되어 있으니, 추천할 만하다. 그림도 이래저래 많이 친절하게 들어가 있어서 따라가기에 좋다. 다만 C를 이미 학습한 사람들에게 있어서 조금 중복되는 부분이 있을 수 있으니, 이는 감안하고 보는 게 좋을 듯 하다.","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://huklee.github.io/categories/Tutorial/"},{"name":"Objective-C","slug":"Tutorial/Objective-C","permalink":"https://huklee.github.io/categories/Tutorial/Objective-C/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://huklee.github.io/tags/Objective-C/"},{"name":"Cocoa","slug":"Cocoa","permalink":"https://huklee.github.io/tags/Cocoa/"},{"name":"iOS","slug":"iOS","permalink":"https://huklee.github.io/tags/iOS/"},{"name":"Mac","slug":"Mac","permalink":"https://huklee.github.io/tags/Mac/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://huklee.github.io/tags/Tutorial/"}]},{"title":"About me (한글)","slug":"007.About-me-ko","date":"2017-01-01T07:08:45.000Z","updated":"2017-02-11T05:18:23.000Z","comments":true,"path":"2017/01/01/007.About-me-ko/","link":"","permalink":"https://huklee.github.io/2017/01/01/007.About-me-ko/","excerpt":"","text":"EnglishRésumé huklee’s blog에 방문해주셨음에 감사드립니다. huklee는 Software Engineer이고, 다음 주제들에 대해서 관심이 많습니다. Big data platform technology such as, Hadoop echo system Spark Machine learning IoT (Internet of Things) technology such as, Connectivity IoT platorm : raspberry pi, arduino Makers : to transform ideas into things 3D Printer makers movement prototyping 저의 블로그의 대부분의 포스트들은 위에 해당하는 내용들에 대해서 공유할 만한 내용들을 다루고 있습니다. 개인적으로 제가 관심 있고, 좋아하는 것들은 아래와 같아요 :) 수영 철인3종경기 서킷트레이닝 클래식 기타 피아노 재즈","categories":[{"name":"About","slug":"About","permalink":"https://huklee.github.io/categories/About/"}],"tags":[{"name":"About","slug":"About","permalink":"https://huklee.github.io/tags/About/"}]},{"title":"About me (English)","slug":"006.About-me","date":"2017-01-01T06:56:35.000Z","updated":"2017-02-16T07:11:09.000Z","comments":true,"path":"2017/01/01/006.About-me/","link":"","permalink":"https://huklee.github.io/2017/01/01/006.About-me/","excerpt":"","text":"KoreanRésumé I am a software engineer and lifelong learner. I’m interested of Big data platform technology such as, Hadoop echo system Spark Machine learning IoT (Internet of Things) technology such as, Connectivity IoT platorm : raspberry pi, arduino Makers : to transform ideas into things 3D Printer makers movement prototyping Most of what I share on this site will align with these interests. I personally love what inspires me such as, swimming triathlon circuit training classical guitar piano jazz","categories":[{"name":"About","slug":"About","permalink":"https://huklee.github.io/categories/About/"}],"tags":[{"name":"About","slug":"About","permalink":"https://huklee.github.io/tags/About/"}]},{"title":"How to multi-boot Ubuntu & Windows","slug":"005.How-to-multi-boot-Ubuntu-Windows","date":"2017-01-01T05:48:00.000Z","updated":"2017-01-18T00:01:57.000Z","comments":true,"path":"2017/01/01/005.How-to-multi-boot-Ubuntu-Windows/","link":"","permalink":"https://huklee.github.io/2017/01/01/005.How-to-multi-boot-Ubuntu-Windows/","excerpt":"","text":"Ubuntu / Windows를 멀티부팅하는 방법우분투와 윈도우를 멀티부팅하는 법은 일단 파티션을 나누어 둔 두 공간 HDD 혹은 SSD를 준비하여 각각에 설치하면 된다. 순서는 Windows -&gt; Ubuntu 순으로 설치를 하자Ubuntu 같은 경우는 나중에 깔아도 Windows를 고려한 부트로더가 동작하기 때문에 유라하다. 반면에 반대로 하면 Windows는 다른 운영체제를 고려하지 않은 방식으로 부트로더가 돌아가기 때문에 곤란한 상황이 발생할 수 있다. 실제로 예전에 반대로 설치를 했다가 윈도우로 부팅이 안 되어서 운영체제를 싹 다 새로 갈아 엎은 경험이 있다. ㅠ.ㅠ 설치 Note SSD : Windows 10 Pro HDD : Ubuntu 15.04 LTS Useful Links윈도우 10에서 우분투 멀티부팅 설치하기 윈도우와 우분투 멀티부팅 팁 - 이것만은 알아두자","categories":[{"name":"Tips","slug":"Tips","permalink":"https://huklee.github.io/categories/Tips/"},{"name":"linux","slug":"Tips/linux","permalink":"https://huklee.github.io/categories/Tips/linux/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://huklee.github.io/tags/Windows/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://huklee.github.io/tags/Ubuntu/"},{"name":"OS","slug":"OS","permalink":"https://huklee.github.io/tags/OS/"},{"name":"Multi-boot","slug":"Multi-boot","permalink":"https://huklee.github.io/tags/Multi-boot/"}]},{"title":"Effective C++ Summary - Chap 01.","slug":"004.Effective-C-Chap-01","date":"2016-12-31T15:09:38.000Z","updated":"2017-01-17T23:59:03.000Z","comments":true,"path":"2017/01/01/004.Effective-C-Chap-01/","link":"","permalink":"https://huklee.github.io/2017/01/01/004.Effective-C-Chap-01/","excerpt":"","text":"Chap 1. C++에 왔으면 C++의 법을 따릅시다.항목 1. C++를 언어들의 연합체(federation) 로 바라보는 안목은 필수C++는 한 가지 프로그래밍 규칙 아래 구성된 통합언어(unified language)가 아니라 네 가지 하위 언어들의 연합체(federation) 라고 보는 것이 언어를 이해하기에 좋다. C 블록, 문장, 선행 처리자, 기본제공 데이터타입, 배열, 포인터 etc… OOP로써의 C++ 클래스를 사용하는 C : 클래스 , 캡슐화, 상속, 다형성, 가상 함수 etc 템플릿 C++ Template Meta-programming : TMP STL 템플릿 라이브러리 : container / iterator / algorithm / function object 항목 2. #define을 쓰려거든const, enum, inline을 떠올리자.매크로인 #define를 수식이나 상수에 사용하는 것은 떄때로 예측할 수 없는 결과를 가져올 수 있으며 , 디버깅에 있어서 비효율적이다. 일례로 아래와 같은 컴파일 에러를 생각해 보자. 123// Bad Example#define ASPECT_RATIO 1.563int ratio = ASPECT_RATIO / 0; 컴파일러로 코드가 넘어간 후에는ASPECT_RATIO가 symbolic name으로 남지 않고,숫자 상수로 대체되어 버린다. 때문에 컴파일러의 기호 테이블에 들어가 있기 때문에 컴파일 에러라도 나면, 복잡한 코드에서는 이를 바로잡기가 쉽지 않다. 특히나 매크로 함수는 큰 재앙이 될 수도 있다. 12345// Bad Example#define CALL_WITH_MAX(a,b) f((a) &gt; (b) ? (a) : (b))int a=5, b=0;CALL_WITH_MAX(++a, b);CALL_WITH_MAX(++a, b + 10); 위와 함수의 경우 a는 7이 되고, 아래의 경우는 6이 되어버린다. 의도되지 않은 결과가 나와버린다. 상수를 선언하는 올바른 코드는 아래와 같다. 12// Good Exampleconst double AspectRatio = 1.653; 클래스 안에서 상수를 사용하고 싶을 때는 static const 혹은 enum을 사용하자. 123456// Good Exampleclass ConstEstimate&#123;private: static const double FudgeFactor = 1.35; enum &#123; NumTurns = 5&#125;;&#125; 매크로 함수의 경우, template function을 사용하면 매크로의 효율적인 코드의 측면을 가져갈 수 있다.123456// Good Exampletemplate&lt;typename T&gt;inline void callWithMax (const T&amp; a, const T&amp; b)&#123; f(a &gt; b ? a : b);&#125; 항목 3. 낌새만 보이면 const를 들이대 보자.const는 컴파일러가 해당 변수 값에 대한 제약을 단단히 지켜준다는 점에서 강력하고 매력적인 도구이다. 다양한 const의 사용 예를 분석해 보자. 1234char *p = greeting; // non-const pointer, non-const dataconst char *p = greeting; // non-const pointer, const datachar *const p = greeting; // const pointer, non-const dataconst char *const p = greeting // const pointer, const data 규칙이 조금은 헷갈리긴 하지만 표시를 기준으로, 왼쪽에 const는 data를 상수로 취취한다. 반면 오른쪽에 있는 const는 포인터 자체를 상수로 취하게 된다. 이는 다음 예를 통해 좀 더 명확히 구분이 가능하다. 12void f1(const int *pw); // non-const pointer, const datavoid f2(int const *pw); // non-const pointer, const data 위의 두 가지 경우에 대해서 모두 가능한 문법이며, 둘 다 int 형의 data가 상수임을 의미한다. f1 방식이 일반적이긴 하나, 둘 다 옳은 표현식이므로 기억해두자. 상수 객체를 생성할 경우에는 그에 맞추어 상수 멤버함수도 정의해줄 필요가 있다. 다음 예제를 보자. 12345678910111213141516#include &lt;iostream&gt;class TextBlock&#123; public: const char&amp; operator[](std::size_t pos) const &#123; return text[position];&#125; char&amp; operator[](std::size_t pos) &#123; return text[position];&#125;&#125;int main()&#123; TextBlock tb(\"Hello\"); std::cout &lt;&lt; tb[0]; const TextBlock ctb(\"World\"); std::cout &lt;&lt; ctb[0]; return 0;&#125; const char&amp; operator[] (std::size_t pos) const에서 중요한 점은 앞의 const는 return 값인 char&amp;가 상수임을 뜻한다. 반면 뒤의 const는 이 멤버 함수가 상수형으로 정의되었으며, 이는 상수 객체에 대해서 적용되는 함수임을 나타내는 부분이다. 추가적으로 공부가 더 필요한 부분 비트수준 상수성(bitwise constness) / 논리적 상수성(logical constness) const_cast, static_cast의 사용 방법 및 사용 예시 이해 항목 4. 객체를 사용하기 전에 반드시 그 객체를 초기화하자.초기화 되지 않은 채 생성된 변수들은 어디에선가 큰 문제를 일으킬 소지가 다분하다. 정의되지 않은 동작이 발생할 가능성이 높기 때문이다. 최악의 경우에는 어떤 플랫폼에서 미초기화 객체를 읽기만 해도 프로그램이 다운되기도 한다. 디버깅을 최대한 줄이기 위해서는 초기화를 하는 것이 효과적이다. built-in type의 객체들은 직접 손으로 초기화하자. 생성자에서는 멤버 초기화 리스트를 사용하자. non-local한 객체는 local하게 바꾸어 사용하자. (non-local한 객체를 만들면 translation unit 단계에서 정의되지 않은 동작이 일어날 수 있다.) Bad Exampleglobal한 변수인 tfs가 중간에 컴파일러 상 어떤 멤버 초기화 과정을 뒤죽박죽으로 할 지 알 수 없어서 위험하다. 1234567class FileSystem&#123; public: std::size_t numDisks() const; ...&#125;extern FileSystem tfs; std::sizet disks = tfs.numDisks(); // bad Example Good Exampletfs()가 local하게 선언되어 있으며, 이는 C++ 컴파일러상 반드시 멤버 초기화 과정을 거치므로 안전하다. 12345678910class FileSystem&#123; public: std::size_t numDisks() const; ...&#125;FileSystem&amp; tfs()&#123; static FileSYstem fs; return fs;&#125;std::sizet disks = tfs().numDisks(); // good example","categories":[{"name":"Programming_Language","slug":"Programming-Language","permalink":"https://huklee.github.io/categories/Programming-Language/"},{"name":"C++","slug":"Programming-Language/C","permalink":"https://huklee.github.io/categories/Programming-Language/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://huklee.github.io/tags/C/"},{"name":"EC++","slug":"EC","permalink":"https://huklee.github.io/tags/EC/"}]},{"title":"Timezone Test","slug":"003.Timezone-Test","date":"2016-11-25T08:20:26.000Z","updated":"2017-01-18T00:02:29.000Z","comments":true,"path":"2016/11/25/003.Timezone-Test/","link":"","permalink":"https://huklee.github.io/2016/11/25/003.Timezone-Test/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Swift Tutorial","slug":"002.Swift-Tutorial","date":"2016-11-25T08:12:10.000Z","updated":"2017-01-18T00:02:30.000Z","comments":true,"path":"2016/11/25/002.Swift-Tutorial/","link":"","permalink":"https://huklee.github.io/2016/11/25/002.Swift-Tutorial/","excerpt":"","text":"Swift TutorialSwift Tutorial pageSwift Playground","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://huklee.github.io/categories/Tutorial/"},{"name":"Swift","slug":"Tutorial/Swift","permalink":"https://huklee.github.io/categories/Tutorial/Swift/"}],"tags":[{"name":"Swift, Cocoa, AppCode","slug":"Swift-Cocoa-AppCode","permalink":"https://huklee.github.io/tags/Swift-Cocoa-AppCode/"}]},{"title":"Hello World","slug":"001.hello-world","date":"2016-11-20T15:10:23.000Z","updated":"2016-11-25T15:29:39.000Z","comments":true,"path":"2016/11/21/001.hello-world/","link":"","permalink":"https://huklee.github.io/2016/11/21/001.hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 1[rectangle setX: 10 y: 10 width: 20 height: 20]; #include using namespace std;int main(){ cout &lt;&lt; “Hello world, C++ “ &lt;&lt; endl;}","categories":[],"tags":[]}]}