{"meta":{"title":"huklee's blog","subtitle":null,"description":null,"author":"huklee","url":"https://huklee.github.io"},"pages":[],"posts":[{"title":"gcc, g++, clang and LLVM","slug":"gcc-g-clang-and-LLVM","date":"2017-01-06T14:32:43.000Z","updated":"2017-01-07T00:02:20.000Z","comments":true,"path":"2017/01/06/gcc-g-clang-and-LLVM/","link":"","permalink":"https://huklee.github.io/2017/01/06/gcc-g-clang-and-LLVM/","excerpt":"","text":"How does g++ work with c++11 codes?Let’s say that we run a simple program which consists of following C++ codes.12345678910111213// test_noc++11.cpp#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int arr[] = &#123;1,2,3&#125;; vector&lt;int&gt; vi(arr, arr + sizeof(arr) / sizeof(arr[0])); for (vector&lt;int&gt;::iterator it=vi.begin(); it != vi.end(); it++)&#123; cout &lt;&lt; *it &lt;&lt; endl; &#125; return 0;&#125; when you build this cpp file, it works well with g++. 12345$ g++ test_noc++11.cpp$ ./a.out123 My question starts from here. What about c++11 codes? Does it work with my complier without any problem? So let me go for it. 12345678910111213// test_c++11.cpp#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int arr[] = &#123;1,2,3&#125;; vector&lt;int&gt; vi(arr, arr + sizeof(arr) / sizeof(arr[0])); for (const int&amp; data : vi)&#123; cout &lt;&lt; data &lt;&lt; endl; &#125; return 0;&#125; This code is using the “Range-based for loop” enhancement in C++11. When I tried to compile this, we can see the warning like following. 123456789$ g++ test.cpptest.cpp:9:23: warning: range-based for loop is a C++11 extension [-Wc++11-extensions] for (const int&amp; data : vi)&#123; ^1 warning generated.$ ./a.out123 It works anyway, what about the version of gcc then? 123456$ g++ --versionConfigured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/usr/include/c++/4.2.1Apple LLVM version 8.0.0 (clang-800.0.38)Target: x86_64-apple-darwin15.6.0Thread model: posixInstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin version Release Date GCC 4.2.2 October 7, 2007 GCC 4.2.1 July 18, 2007 GCC 4.2.0 May 13, 2007 the version of gcc is indeed 4.2.1, which doesn’t support C++11 since it’s developed in 2007. What are clang and LLVM?So what makes my code work? What are clang and LLVM? Let’s go a little deeper. Clang /ˈklæŋ/[4] is a compiler front end for the programming languages C, C++, Objective-C, Objective-C++, OpenMP,[5] OpenCL, and CUDA. It uses LLVM as its back end and has been part of the LLVM release cycle since LLVM 2.6. from Wikipedia The LLVM compiler infrastructure project (formerly Low Level Virtual Machine) is a “collection of modular and reusable compiler and toolchain technologies” used to develop compiler front ends and back ends.LLVM is written in C++ and is designed for compile-time, link-time, run-time, and “idle-time” optimization of programs written in arbitrary programming languages. Originally implemented for C and C++, the language-agnostic design of LLVM has since spawned a wide variety of front ends: languages with compilers that use LLVM include ActionScript, Ada, C#, Common Lisp, Crystal, D, Delphi, Fortran, OpenGL Shading Language, Halide, Haskell, Java bytecode, Julia, Lua, Objective-C, Pony, Python, R, Ruby, Rust, CUDA, Scala, and Swift. from Wikipedia All right. I just figured out when I run the g++, llvm-gcc is indeed running, which is the gcc frontend, and then the llvm backend. On the other side, clang++ is running clang, which is the clang frontend and then the llvm backend. Following So, my g++ is actually using clang-LLVM 8.0, which supports c++11, even c++14. DONE. Further questions what are front-end compiler and back-end complier? I should’ve taken the complier coursework during my B.S :( who made the clang &amp; LLVM? are they open-source projects? LinksC++11 WikipediaC++11 Tutorial VideoAdded featured in C++11 Slidegcc release noteclang project homepageclang Wikipedia[LLVM Wikipedia] (https://en.wikipedia.org/wiki/LLVM)g++, clang++ on mac","categories":[{"name":"C++","slug":"C","permalink":"https://huklee.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://huklee.github.io/tags/C/"},{"name":"gcc","slug":"gcc","permalink":"https://huklee.github.io/tags/gcc/"},{"name":"g++","slug":"g","permalink":"https://huklee.github.io/tags/g/"},{"name":"clang","slug":"clang","permalink":"https://huklee.github.io/tags/clang/"},{"name":"LLVM","slug":"LLVM","permalink":"https://huklee.github.io/tags/LLVM/"},{"name":"compiler","slug":"compiler","permalink":"https://huklee.github.io/tags/compiler/"}]},{"title":"leetcode_two-sum","slug":"leetcode-two-sum","date":"2017-01-03T13:53:01.000Z","updated":"2017-01-04T11:47:57.000Z","comments":true,"path":"2017/01/03/leetcode-two-sum/","link":"","permalink":"https://huklee.github.io/2017/01/03/leetcode-two-sum/","excerpt":"","text":"leetcode problem solvinghttps://leetcode.com/problems/two-sum/ Brute-force solution : O(n^2)1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; // 1. O(n^2) solution // Brute-force : pick the two number; vector&lt;int&gt; answer = vector&lt;int&gt;(); for (int i=0; i &lt; nums.size(); i++)&#123; int pivot = nums[i]; for (int j=i + 1; j &lt; nums.size(); j++)&#123; int sum = pivot + nums[j]; if(sum == target)&#123; answer.push_back(i); answer.push_back(j); return answer; &#125; &#125; &#125; return answer; &#125;&#125; Hash table using solution : O(n)The key idea is the complement of an answer number must exist (an answer number + the complement number = target). So we just should minimize the time to find the complement number, which I found a hash table is the one. Search the complement number in the existing hash table, and if not found, add the number to the hash table.DONE 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; // 2. O(n) solution // using hash table unordered_map&lt;int, int&gt; hash_table; vector&lt;int&gt; answer = vector&lt;int&gt;(); for (int i=0; i &lt; nums.size(); i++)&#123; int complement = target - nums[i]; if (hash_table.find(complement) != hash_table.end())&#123; answer.push_back(hash_table[complement]); answer.push_back(i); return answer; &#125; hash_table[nums[i]] = i; &#125; return answer; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://huklee.github.io/categories/leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://huklee.github.io/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://huklee.github.io/tags/leetcode/"},{"name":"two-sum","slug":"two-sum","permalink":"https://huklee.github.io/tags/two-sum/"},{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/tags/algorithm/"},{"name":"array","slug":"array","permalink":"https://huklee.github.io/tags/array/"}]},{"title":"Objective-C Tutorials","slug":"Objective-C-Tutorials","date":"2017-01-01T08:27:52.000Z","updated":"2017-01-07T23:13:19.000Z","comments":true,"path":"2017/01/01/Objective-C-Tutorials/","link":"","permalink":"https://huklee.github.io/2017/01/01/Objective-C-Tutorials/","excerpt":"","text":"Objective-C Tutorial pages기본적인 Objective-C를 학습하는 데 있어서 필요한 튜토리얼들을 대충 정리해 보았다. Objective-C의 기본개념기본적인 Objective C의 문법과 개념에 대해서 다루고 있는 페이지다. Scott Stevenson의 Objective-C 튜토리얼을 번역한 글이다. 전체적으로 C에서 Objective-C가 어떤 부분에서 다르고, 실제 iOS 어플리케이션을 만들 때 어떤 부분들이 필요한지에 대해서 다루었다. 다만, 기초적인 Tutorial이라고 표현하기에 예제가 부족하고, 개념을 주로 설명하는 편이어서 Objective-C의 지식이 전무한 상태에서 따라가기에는 조금 안 좋아 보인다. 어느 정도 Objective-C의 개념을 훑어보기에 좋다. Objective-C 따라하기 강좌기초적인 예제 중심으로 Objective-C 프로그램을 개발하기에 필요한 부분들을 학습할 수 있는 Tutorial이다. 무작정 따라하기에는 쉽고, 빨리 따라할 수 있는 구성으로 되어 있으니, 추천할 만하다. 그림도 이래저래 많이 친절하게 들어가 있어서 따라가기에 좋다. 다만 C를 이미 학습한 사람들에게 있어서 조금 중복되는 부분이 있을 수 있으니, 이는 감안하고 보는 게 좋을 듯 하다.","categories":[{"name":"Tutorials","slug":"Tutorials","permalink":"https://huklee.github.io/categories/Tutorials/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://huklee.github.io/tags/Objective-C/"},{"name":"Cocoa","slug":"Cocoa","permalink":"https://huklee.github.io/tags/Cocoa/"},{"name":"iOS","slug":"iOS","permalink":"https://huklee.github.io/tags/iOS/"},{"name":"Mac","slug":"Mac","permalink":"https://huklee.github.io/tags/Mac/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://huklee.github.io/tags/Tutorial/"}]},{"title":"About me (한글)","slug":"About-me-ko","date":"2017-01-01T07:08:45.000Z","updated":"2017-01-01T07:24:17.000Z","comments":true,"path":"2017/01/01/About-me-ko/","link":"","permalink":"https://huklee.github.io/2017/01/01/About-me-ko/","excerpt":"","text":"EnglishCV huklee’s blog에 방문해주셨음에 감사드립니다. huklee는 Software Engineer이고, 다음 주제들에 대해서 관심이 많습니다. Big data platform technology such as, Hadoop echo system Spark Machine learning IoT (Internet of Things) technology such as, Connectivity IoT platorm : raspberry pi, arduino Makers : to transform ideas into things 3D Printer makers movement prototyping 저의 블로그의 대부분의 포스트들은 위에 해당하는 내용들에 대해서 공유할 만한 내용들을 다루고 있습니다. 개인적으로 제가 관심 있고, 좋아하는 것들은 아래와 같아요 :) 수영 철인3종경기 서킷트레이닝 클래식 기타 피아노 재즈","categories":[{"name":"About","slug":"About","permalink":"https://huklee.github.io/categories/About/"}],"tags":[{"name":"About","slug":"About","permalink":"https://huklee.github.io/tags/About/"}]},{"title":"About me (English)","slug":"About-me","date":"2017-01-01T06:56:35.000Z","updated":"2017-01-01T07:22:45.000Z","comments":true,"path":"2017/01/01/About-me/","link":"","permalink":"https://huklee.github.io/2017/01/01/About-me/","excerpt":"","text":"KoreanCV I am a software engineer and lifelong learner. I’m interested of Big data platform technology such as, Hadoop echo system Spark Machine learning IoT (Internet of Things) technology such as, Connectivity IoT platorm : raspberry pi, arduino Makers : to transform ideas into things 3D Printer makers movement prototyping Most of what I share on this site will align with these interests. I personally love what inspires me such as, swimming triathlon circuit training classical guitar piano jazz","categories":[{"name":"About","slug":"About","permalink":"https://huklee.github.io/categories/About/"}],"tags":[{"name":"About","slug":"About","permalink":"https://huklee.github.io/tags/About/"}]},{"title":"How to multi-boot Ubuntu & Windows","slug":"How-to-multi-boot-Ubuntu-Windows","date":"2017-01-01T05:48:00.000Z","updated":"2017-01-01T06:57:36.000Z","comments":true,"path":"2017/01/01/How-to-multi-boot-Ubuntu-Windows/","link":"","permalink":"https://huklee.github.io/2017/01/01/How-to-multi-boot-Ubuntu-Windows/","excerpt":"","text":"Ubuntu / Windows를 멀티부팅하는 방법우분투와 윈도우를 멀티부팅하는 법은 일단 파티션을 나누어 둔 두 공간 HDD 혹은 SSD를 준비하여 각각에 설치하면 된다. 순서는 Windows -&gt; Ubuntu 순으로 설치를 하자Ubuntu 같은 경우는 나중에 깔아도 Windows를 고려한 부트로더가 동작하기 때문에 유라하다. 반면에 반대로 하면 Windows는 다른 운영체제를 고려하지 않은 방식으로 부트로더가 돌아가기 때문에 곤란한 상황이 발생할 수 있다. 실제로 예전에 반대로 설치를 했다가 윈도우로 부팅이 안 되어서 운영체제를 싹 다 새로 갈아 엎은 경험이 있다. ㅠ.ㅠ 설치 Note SSD : Windows 10 Pro HDD : Ubuntu 15.04 LTS Useful Links윈도우 10에서 우분투 멀티부팅 설치하기 윈도우와 우분투 멀티부팅 팁 - 이것만은 알아두자","categories":[],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://huklee.github.io/tags/Windows/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://huklee.github.io/tags/Ubuntu/"},{"name":"OS","slug":"OS","permalink":"https://huklee.github.io/tags/OS/"},{"name":"Multi-boot","slug":"Multi-boot","permalink":"https://huklee.github.io/tags/Multi-boot/"}]},{"title":"Effective C++ Summary - Chap 01.","slug":"Effective-C-Chap-01","date":"2016-12-31T15:09:38.000Z","updated":"2017-01-07T23:12:28.000Z","comments":true,"path":"2017/01/01/Effective-C-Chap-01/","link":"","permalink":"https://huklee.github.io/2017/01/01/Effective-C-Chap-01/","excerpt":"","text":"Chap 1. C++에 왔으면 C++의 법을 따릅시다.항목 1. C++를 언어들의 연합체(federation) 로 바라보는 안목은 필수C++는 한 가지 프로그래밍 규칙 아래 구성된 통합언어(unified language)가 아니라 네 가지 하위 언어들의 연합체(federation) 라고 보는 것이 언어를 이해하기에 좋다. C 블록, 문장, 선행 처리자, 기본제공 데이터타입, 배열, 포인터 etc… OOP로써의 C++ 클래스를 사용하는 C : 클래스 , 캡슐화, 상속, 다형성, 가상 함수 etc 템플릿 C++ Template Meta-programming : TMP STL 템플릿 라이브러리 : container / iterator / algorithm / function object 항목 2. #define을 쓰려거든const, enum, inline을 떠올리자.매크로인 #define를 수식이나 상수에 사용하는 것은 떄때로 예측할 수 없는 결과를 가져올 수 있으며 , 디버깅에 있어서 비효율적이다. 일례로 아래와 같은 컴파일 에러를 생각해 보자. 123// Bad Example#define ASPECT_RATIO 1.563int ratio = ASPECT_RATIO / 0; 컴파일러로 코드가 넘어간 후에는ASPECT_RATIO가 symbolic name으로 남지 않고,숫자 상수로 대체되어 버린다. 때문에 컴파일러의 기호 테이블에 들어가 있기 때문에 컴파일 에러라도 나면, 복잡한 코드에서는 이를 바로잡기가 쉽지 않다. 특히나 매크로 함수는 큰 재앙이 될 수도 있다. 12345// Bad Example#define CALL_WITH_MAX(a,b) f((a) &gt; (b) ? (a) : (b))int a=5, b=0;CALL_WITH_MAX(++a, b);CALL_WITH_MAX(++a, b + 10); 위와 함수의 경우 a는 7이 되고, 아래의 경우는 6이 되어버린다. 의도되지 않은 결과가 나와버린다. 상수를 선언하는 올바른 코드는 아래와 같다. 12// Good Exampleconst double AspectRatio = 1.653; 클래스 안에서 상수를 사용하고 싶을 때는 static const 혹은 enum을 사용하자. 123456// Good Exampleclass ConstEstimate&#123;private: static const double FudgeFactor = 1.35; enum &#123; NumTurns = 5&#125;;&#125; 매크로 함수의 경우, template function을 사용하면 매크로의 효율적인 코드의 측면을 가져갈 수 있다.123456// Good Exampletemplate&lt;typename T&gt;inline void callWithMax (const T&amp; a, const T&amp; b)&#123; f(a &gt; b ? a : b);&#125; 항목 3. 낌새만 보이면 const를 들이대 보자.const는 컴파일러가 해당 변수 값에 대한 제약을 단단히 지켜준다는 점에서 강력하고 매력적인 도구이다. 다양한 const의 사용 예를 분석해 보자. 1234char *p = greeting; // non-const pointer, non-const dataconst char *p = greeting; // non-const pointer, const datachar *const p = greeting; // const pointer, non-const dataconst char *const p = greeting // const pointer, const data 규칙이 조금은 헷갈리긴 하지만 표시를 기준으로, 왼쪽에 const는 data를 상수로 취취한다. 반면 오른쪽에 있는 const는 포인터 자체를 상수로 취하게 된다. 이는 다음 예를 통해 좀 더 명확히 구분이 가능하다. 12void f1(const int *pw); // non-const pointer, const datavoid f2(int const *pw); // non-const pointer, const data 위의 두 가지 경우에 대해서 모두 가능한 문법이며, 둘 다 int 형의 data가 상수임을 의미한다. f1 방식이 일반적이긴 하나, 둘 다 옳은 표현식이므로 기억해두자. 상수 객체를 생성할 경우에는 그에 맞추어 상수 멤버함수도 정의해줄 필요가 있다. 다음 예제를 보자. 12345678910111213141516#include &lt;iostream&gt;class TextBlock&#123; public: const char&amp; operator[](std::size_t pos) const &#123; return text[position];&#125; char&amp; operator[](std::size_t pos) &#123; return text[position];&#125;&#125;int main()&#123; TextBlock tb(\"Hello\"); std::cout &lt;&lt; tb[0]; const TextBlock ctb(\"World\"); std::cout &lt;&lt; ctb[0]; return 0;&#125; const char&amp; operator[] (std::size_t pos) const에서 중요한 점은 앞의 const는 return 값인 char&amp;가 상수임을 뜻한다. 반면 뒤의 const는 이 멤버 함수가 상수형으로 정의되었으며, 이는 상수 객체에 대해서 적용되는 함수임을 나타내는 부분이다. 추가적으로 공부가 더 필요한 부분 비트수준 상수성(bitwise constness) / 논리적 상수성(logical constness) const_cast, static_cast의 사용 방법 및 사용 예시 이해 항목 4. 객체를 사용하기 전에 반드시 그 객체를 초기화하자.초기화 되지 않은 채 생성된 변수들은 어디에선가 큰 문제를 일으킬 소지가 다분하다. 정의되지 않은 동작이 발생할 가능성이 높기 때문이다. 최악의 경우에는 어떤 플랫폼에서 미초기화 객체를 읽기만 해도 프로그램이 다운되기도 한다. 디버깅을 최대한 줄이기 위해서는 초기화를 하는 것이 효과적이다. built-in type의 객체들은 직접 손으로 초기화하자. 생성자에서는 멤버 초기화 리스트를 사용하자. non-local한 객체는 local하게 바꾸어 사용하자. (non-local한 객체를 만들면 translation unit 단계에서 정의되지 않은 동작이 일어날 수 있다.) Bad Exampleglobal한 변수인 tfs가 중간에 컴파일러 상 어떤 멤버 초기화 과정을 뒤죽박죽으로 할 지 알 수 없어서 위험하다. 1234567class FileSystem&#123; public: std::size_t numDisks() const; ...&#125;extern FileSystem tfs; std::sizet disks = tfs.numDisks(); // bad Example Good Exampletfs()가 local하게 선언되어 있으며, 이는 C++ 컴파일러상 반드시 멤버 초기화 과정을 거치므로 안전하다. 12345678910class FileSystem&#123; public: std::size_t numDisks() const; ...&#125;FileSystem&amp; tfs()&#123; static FileSYstem fs; return fs;&#125;std::sizet disks = tfs().numDisks(); // good example","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://huklee.github.io/tags/C/"},{"name":"EC++","slug":"EC","permalink":"https://huklee.github.io/tags/EC/"}]},{"title":"image test","slug":"test","date":"2016-11-25T08:48:03.000Z","updated":"2016-12-31T14:33:06.000Z","comments":true,"path":"2016/11/25/test/","link":"","permalink":"https://huklee.github.io/2016/11/25/test/","excerpt":"","text":"","categories":[{"name":"Image","slug":"Image","permalink":"https://huklee.github.io/categories/Image/"}],"tags":[{"name":"image","slug":"image","permalink":"https://huklee.github.io/tags/image/"},{"name":"test","slug":"test","permalink":"https://huklee.github.io/tags/test/"},{"name":"layout","slug":"layout","permalink":"https://huklee.github.io/tags/layout/"}]},{"title":"Timezone Test","slug":"Timezone-Test","date":"2016-11-25T08:20:26.000Z","updated":"2016-11-25T10:23:03.000Z","comments":true,"path":"2016/11/25/Timezone-Test/","link":"","permalink":"https://huklee.github.io/2016/11/25/Timezone-Test/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Swift Tutorial","slug":"Swift-Tutorial","date":"2016-11-25T08:12:10.000Z","updated":"2016-11-25T10:23:03.000Z","comments":true,"path":"2016/11/25/Swift-Tutorial/","link":"","permalink":"https://huklee.github.io/2016/11/25/Swift-Tutorial/","excerpt":"","text":"Swift TutorialSwift Tutorial pageSwift Playground","categories":[],"tags":[{"name":"Swift, Cocoa, AppCode","slug":"Swift-Cocoa-AppCode","permalink":"https://huklee.github.io/tags/Swift-Cocoa-AppCode/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-11-20T15:10:23.000Z","updated":"2016-11-25T15:29:39.000Z","comments":true,"path":"2016/11/21/hello-world/","link":"","permalink":"https://huklee.github.io/2016/11/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 1[rectangle setX: 10 y: 10 width: 20 height: 20]; #include using namespace std;int main(){ cout &lt;&lt; “Hello world, C++ “ &lt;&lt; endl;}","categories":[],"tags":[]}]}