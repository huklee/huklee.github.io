{"meta":{"title":"huklee's blog","subtitle":null,"description":null,"author":"huklee","url":"https://huklee.github.io"},"pages":[{"title":"Categories","date":"2017-03-01T06:36:54.000Z","updated":"2017-01-17T23:36:07.000Z","comments":true,"path":"categories/index.html","permalink":"https://huklee.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-03-01T06:36:54.000Z","updated":"2017-01-17T23:36:18.000Z","comments":true,"path":"tags/index.html","permalink":"https://huklee.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"github tutorials","slug":"055.github-tutorials","date":"2017-03-15T14:35:36.000Z","updated":"2017-03-15T14:44:42.000Z","comments":true,"path":"2017/03/15/055.github-tutorials/","link":"","permalink":"https://huklee.github.io/2017/03/15/055.github-tutorials/","excerpt":"","text":"Github tutorialsGithub에 대해서 입문자로서 대략적인 기능들과 구조에 대해서 쭉 공부를 해 보았다. 간단하게 정리해보자면 대충 아래와 같다. 조금 더 손볼 부분이 있긴 하지만 일단 이 정도로 정리하고 추가하도록 하겠다. Make a repository Github Clone Github Branch Github Commit &amp; Push Pull Request Merge Request Github Tutorial : 지옥에서 온 Git 수업소개 git의 원리 Branch git을 이용한 프로젝트의 흐름 Useful linksThe Basics of Git and Github UML Diagram : Github Startup 지옥에서 온 Git","categories":[{"name":"tutorials","slug":"tutorials","permalink":"https://huklee.github.io/categories/tutorials/"}],"tags":[{"name":"github","slug":"github","permalink":"https://huklee.github.io/tags/github/"},{"name":"git","slug":"git","permalink":"https://huklee.github.io/tags/git/"}]},{"title":"IoT Solutions at big 4","slug":"054.IoT-Solution-at-Big-4","date":"2017-03-10T15:42:33.000Z","updated":"2017-03-12T11:45:06.000Z","comments":true,"path":"2017/03/11/054.IoT-Solution-at-Big-4/","link":"","permalink":"https://huklee.github.io/2017/03/11/054.IoT-Solution-at-Big-4/","excerpt":"","text":"Google IoT 조대협의 구글 IoT 소개 coursera : 구글 클라우드 플랫폼 강좌 Facebook IoT 2013 ~ 2015 : parse에 대한 투자 집중 BaaS (Back-end as a server) 전략의 일환Facebook이 공개한 미래 전략, 그리고 주목되는 IoT 전략 2016 : parse 에 대한 투자 방향 급감Why Facebook Inc. Abandoned Its App and Internet of Things Platform","categories":[{"name":"draft","slug":"draft","permalink":"https://huklee.github.io/categories/draft/"}],"tags":[{"name":"IoT","slug":"IoT","permalink":"https://huklee.github.io/tags/IoT/"}]},{"title":"Effective C++ Summary - Chap 02","slug":"053.Effective-C-Summary-Chap-02","date":"2017-03-09T15:00:52.000Z","updated":"2017-03-09T15:30:16.000Z","comments":true,"path":"2017/03/10/053.Effective-C-Summary-Chap-02/","link":"","permalink":"https://huklee.github.io/2017/03/10/053.Effective-C-Summary-Chap-02/","excerpt":"","text":"Chap 2. 생성자, 소멸자 및 대입 연산자항목 5. C++가 은근슬쩍 만들어 호출해 버리는 함수들에 촉각을 세우자.항목 6. 컴파일러가 만들어낸 함수가 필요 없으면 확실히 이들의 사용을 금해 버리자. 기본적으로 컴파일러는 class에 대해서 기본적으로 다음 4가지를 생성한다 : constructor, copy constructor, copy assignment operator, destructor 이에 따라 의도되지 않은 undefined behavior의 발생에 주의하자. ex) copy of reference member 컴파일러가 만들어낸 함수가 사용되지 않게 하고 싶은 경우에는 사용되지 않도록 장치를 해두자. C++ 언어에서 기본적으로 class를 생성할 경우에 아래 네 가지 함수를 정의해준다. constructor destructor copy constructor copy assignment operator 코드로 보자면 1234class Emtpy(private: std::string&amp; str_ref;); 는 다음과 같다. 12345678910class Emtpty()&#123;public: Empty() &#123;...&#125; EMpty(const Emtpty&amp; rhs) &#123;...&#125; ~Empty() &#123;...&#125; Empty &amp;operator=(const Empty&amp; rhs) &#123;...&#125;private: std::string&amp; str_ref; &#125;; 위와 같은 경우, 다음과 같은 코드를 사용하면 에러가 발생할 수 있다. 1234567std::string s1(\"hello\");std::string s2(\"hi\");Empty p1(s1);Empty p2(s2);p1 = p2; // error occured 실제로는 아래와 같은 코드가 실행되는 것인데, reference 변수는 초기화는 가능하지만, 중간에 대입는 불가능하기 때문에, 아래와 같은 코드는 컴파일 에러가 발생하게 되는 것이 일반적이다. 1p1.str_ref = p2.str_ref; // error 위와 같은 발생 가능성 때문에 모든 constructor, destructor, copy assignment operator, copy constructor에 대해서는 정의를 명시적으로 해 주거나, 사용되지 않도록 하는 것이 좋은 방법이다. 사용되지 않도록 하는 방법은 아래와 같다. private 속성으로 함수를 선언해 놓고, 구현해 놓지 않는다.이 방법은 컴파일 에러를 통해서 프로그래머의 에러를 사전에 막아주는 효과가 있다. 예를 들면 아래와 같이 해 주는 방식이다. 123456789class Uncopy&#123;public: Uncopy() &#123;...&#125;; ~Uncopy() &#123;...&#125;;private: Uncopy(const Uncopy&amp;); // only declaration Uncopy&amp; operator=(const Uncopy&amp;); // only declaration&#125;; 아래처럼 class 상속을 통해서 해결하는 방법도 있다. 다만 이렇게 하면 다중상속을 고려해야 하는 상황이 생길 수 있으므로, 거기에 따른 복잡성을 고려해도 괜찮은 경우에만 사용하자. 12345678910111213class Uncopyable&#123;public: Uncopyable() &#123;...&#125;; ~Uncopyable() &#123;...&#125;;private: Uncopyable(const Uncopyable&amp;); // only declaration Uncopyable&amp; operator=(const Uncopyable&amp;); // only declaration&#125;;class Uncopy : private Uncopyable&#123; ...&#125;;","categories":[{"name":"Programming_Language","slug":"Programming-Language","permalink":"https://huklee.github.io/categories/Programming-Language/"},{"name":"C++","slug":"Programming-Language/C","permalink":"https://huklee.github.io/categories/Programming-Language/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://huklee.github.io/tags/C/"},{"name":"EC++","slug":"EC","permalink":"https://huklee.github.io/tags/EC/"}]},{"title":"2D graphic C++ libraries","slug":"052.2D-graphic-C-libraries","date":"2017-03-05T08:34:12.000Z","updated":"2017-03-16T14:45:18.000Z","comments":true,"path":"2017/03/05/052.2D-graphic-C-libraries/","link":"","permalink":"https://huklee.github.io/2017/03/05/052.2D-graphic-C-libraries/","excerpt":"","text":"C++ Open Source librariesA list of open source C++ libraries C++ graphics libraries in 2DC++ Graphic library : CairommCairomm : image-surfaceCairomm : tutorial cImag CImg 사용법 컴파일 방법 png를 로드하려면 libpng를 외부에서 가져와 줘야 한다. 그러기 위해서는 libpng를 미리 설치해 주어야 하고, (libzip은 기본으로 깔려 있다고 가정하자) Make에서 아래 구문을 추가해 주어야 한다. 1-Dcimg_use_png -lpng -lz 그러면 실제로 컴파일 할 떄는 아래와 같이 된다. 그냥 한꺼번에 소스에서 포함시켜서 바로 묶어서 build 하는 법에 대해서는 조금 더 자세히 알아봐야 할 것 같다. 1c++ -o test_simple test_simple.cpp -I.. -Wall -Wextra -Wfatal-errors -std=c++11 -pedantic -Dcimg_use_vt100 -Dcimg_display=1 -I/usr/X11R6/include -lm -L/usr/X11R6/lib -lX11 -lpthread -Dcimg_use_png -lpng -lz 소스코드 Image format source librarieslibpngpng파일을 읽을 수 있는 원본 소스. C로 짜여져 있으며, binary로 받아서 빌드하기에는 그냥 사용하기에는 무척 난해한 편이다. 기본적으로 mac os X 에서 사용하려면 다음 절차를 따라서 설치해주면 된다. open Terminal and run the following script 1$ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" &lt; /dev/null 2&gt; /dev/null and press enter/return key. Wait for the command to finish. Run: 1$ brew install libpng install libpng on a Mac example sourceA simple libpng example program How to build a code using libpng library libmngmng파일 포맷을 지원하는 library. 그리 유명하진 않은 편. Useful linkswhen using png file format in cImg when using jpeg file format in cImg Make 기반 빌드 시스템 (2): Makefile 기초","categories":[{"name":"programming","slug":"programming","permalink":"https://huklee.github.io/categories/programming/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://huklee.github.io/tags/C/"}]},{"title":"introduction to system design","slug":"051.introduction-to-system-design","date":"2017-03-01T06:16:57.000Z","updated":"2017-03-01T09:36:51.000Z","comments":true,"path":"2017/03/01/051.introduction-to-system-design/","link":"","permalink":"https://huklee.github.io/2017/03/01/051.introduction-to-system-design/","excerpt":"","text":"Introduction to system designTheories &amp; IntroComplex System Design : 15 Design Thinking Intro to Architecture &amp; System Design Intro to Design Pattern ExampleSoftware architecture Example : alram clock programming interview Elevator System Design example : Designin Google Docs Scalable ArchitectureScalable architectures Principles of Scalable System Design 8 Commonly Used scalable System Design patterns","categories":[],"tags":[{"name":"Architecture","slug":"Architecture","permalink":"https://huklee.github.io/tags/Architecture/"},{"name":"system design","slug":"system-design","permalink":"https://huklee.github.io/tags/system-design/"}]},{"title":"docker : construct a server with a docker file","slug":"050.docker-construct-a-server-with-a-docker-file","date":"2017-02-28T11:24:08.000Z","updated":"2017-03-01T01:49:35.000Z","comments":true,"path":"2017/02/28/050.docker-construct-a-server-with-a-docker-file/","link":"","permalink":"https://huklee.github.io/2017/02/28/050.docker-construct-a-server-with-a-docker-file/","excerpt":"","text":"Docker terms docker image 서비스 운영에 필요한 서버 프로그램, 운영체제, 컴파일된 환경 모두를 통째로 묶은 형태 container image를 실행한 상태 Dockerfile Dockefile는 인프라 구성 정보를 담고 있는 일종의 docker script이다. dockerfile 이미지를 build할 떄 파일을 지정해 주면 동작하게 돈다.명령어는 다음과 같다 TITLE function FROM 이미지 설정 RUN 이미지를 생성하기 위한 명령 CMD docker container 안에서 실행되는 명령 ENTRYPOINT docker run 커맨드에 선행하여 실행되는 명령 USER 명령어 실행의 사용자 지정 LABEL version, description 같은 정보 저장 COPY image에 파일 및 디렉토리 복사 ADD image에 파일 및 디렉토리 추가 (다운로드, 압축풀기 가능) VOLUME image에서 호스트에서 공유되는 access point(=volume)를 할당 Docker 이미지 생성 및 구동 BUILD : dockerfile 로 이미지 생성dockerfile로 이미지를 중첩하여 build 하는 것이 가능하다. 여러 이미지를 중첩시키면 그에 따라 image가 stack처럼 쌓이게 된다. image layer example ONBUILD : bulid 완료 후에 커멘드가 실행되도록 설정 Useful links도커 무작정 따라하기 slides","categories":[{"name":"docker","slug":"docker","permalink":"https://huklee.github.io/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://huklee.github.io/tags/docker/"}]},{"title":"how to docker install","slug":"049.how-to-docker-install","date":"2017-02-28T01:47:26.000Z","updated":"2017-03-01T01:52:50.000Z","comments":true,"path":"2017/02/28/049.how-to-docker-install/","link":"","permalink":"https://huklee.github.io/2017/02/28/049.how-to-docker-install/","excerpt":"","text":"Install docker in CLI Install Homebrew 1ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" Install docker toolbox 12brew cask install docker-toolboxbrew install caskroom/cask/brew-cask How to Start docker check the docker version 1docker version list the docker machine 1docker-machine ls create the docker machine 1docker-machine create --driver \"virtualbox\" myBoxName start the docker machine 1docker-machine start myBoxName get into the env of the docker machine 1eval $(docker-machine env myBoxName) 123456export DOCKER_TLS_VERIFY=\"1\"export DOCKER_HOST=\"tcp://192.168.99.100:2376\"export DOCKER_CERT_PATH=\"/Users/huklee/.docker/machine/machines/myBoxName\"export DOCKER_MACHINE_NAME=\"myBoxName\"# Run this command to configure your shell:# eval $(docker-machine env myBoxName) when the certification is not working 1docker-machine regenerate-certs myBoxName Start the docker image on the docker box see the docker image list 1docker images search the docker images on web 12docker search [image]# ex) docker search centos download the docker image 1docker pull centos:latest the simple test of docker 123456docker run hello-worlddocker run -d -i -t --name \"test2\" ubuntu /bin/bash # -d : backgrounddocker run -it --name \"test1\" centos /bin/caldocker ps attach the docker process 1docker attach hello to exit without stop : docker daemon이 꺼져 있는 경우 / docker server is off Mac에서는 일단 docker Quickstart Terminal을 찾아서 키면 자동으로 docker daemon default 세팅이 된다. 이후에 아래 명령을 실행해 주면 된다.1eval $(docker-machine env myBoxName) 궁금한 점들 docker를 사용해서 ubuntu / centos 등을 실행시키면 실제 파일 저장 경로라던가 하는 것들은 어떻게 되는 것인지? 왜 sudo 를 사용하면 docker-toolbox를 사용했을 때, 에러가 나는가. 왜 그렇게 ubuntu같은 것들도 용량이 무지하게 작은가? file system을 공유해서 실제 file directory처럼 사용하는 것이 가능한가? Docker 데이터 볼륨 사용하기 install docker with homebrew on Mac docker 개념잡기 : 아키텍쳐","categories":[{"name":"docker","slug":"docker","permalink":"https://huklee.github.io/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://huklee.github.io/tags/docker/"}]},{"title":"python map, reduce, filter, zip built-in functions","slug":"048.python-map-reduce-filter-zip-built-in-functions","date":"2017-02-25T07:12:57.000Z","updated":"2017-02-25T08:57:40.000Z","comments":true,"path":"2017/02/25/048.python-map-reduce-filter-zip-built-in-functions/","link":"","permalink":"https://huklee.github.io/2017/02/25/048.python-map-reduce-filter-zip-built-in-functions/","excerpt":"","text":"python built-in functions : map / reduce / filter / zip예전에 파이썬을 배웠을 때는 다 배웠었는데, 잘 안 사용하다가 사용법도 헷갈려서 참고차 정리해 보려고 한다! notice 이 예제들은 python 3.6.0을 기준으로 작성되었음 python 2의 경우에 몇 가지 주의할 점 list(map(…)), list(reduce(…))등을 쓸 필요 없이 바로 map(…), reduce(…)을 바로 list 타입으로 사용 가능 from functools import reduce 사용할 필요 없이 바로 reduce(…) 사용 가능 Map, reduce, filtermap 12345class map(object) | map(func, *iterables) --&gt; map object | | Make an iterator that computes the function using arguments from | each of the iterables. Stops when the shortest iterable is exhausted. map은 함수를 iterable한 list, tuple, set, dictionary 등에 대해서 원소별 결과를 모아서 return해준다. 따라서 function의 경우, input argument의 경우 1개인 함수만 사용 가능하다. 함수는 labmda를 사용하여 anonymous fucntion을 넘겨주어도 좋고, def를 사용해서 함수 변수를 사용해도 된다. example12345678910def square1(x): return x**2square2 = lambda x:x**2arr = list(range(5))list(map(lambda x:x**2, arr))list(map(square1, arr))list(map(square2, arr))# [0, 1, 4, 9, 16] reduce 12345reduce(...) reduce(function, sequence[, initial]) -&gt; value Apply a function of two arguments cumulatively to the items of a sequence, from left to right, so as to reduce the sequence to a single value. reduce는 map과 달리 여러 iterable한 elem들을 한 개로 쭉 모아주는 역할을 수행할 수 있다. 2개씩 모아서 함수를 수행하므로, input argument가 2개인 함수만 사용이 가능하다. 예를 들어서 아래와 같이 * operator를 누적하면 factorial을 만든다던가, accumulated sum를 간단하게 구현할 수 있다. 1234567891011from functools import reducedef fact(n): return reduce(lambda x,y:x*y, range(1,n + 1))def accSum(n): return reduce(lambda x,y:x+y, range(1,n + 1))print(fact(5))# 120print(accSum(10))# 55 filterzip, unzipzipunzip","categories":[{"name":"draft","slug":"draft","permalink":"https://huklee.github.io/categories/draft/"}],"tags":[{"name":"python","slug":"python","permalink":"https://huklee.github.io/tags/python/"}]},{"title":"mapreduce in python","slug":"047.mapreduce-in-python","date":"2017-02-25T06:21:46.000Z","updated":"2017-02-26T02:45:18.000Z","comments":true,"path":"2017/02/25/047.mapreduce-in-python/","link":"","permalink":"https://huklee.github.io/2017/02/25/047.mapreduce-in-python/","excerpt":"","text":"multiprocessing pool function in Python built-in123456789101112def f(x): return x*xif __name__ == '__main__': t = timer() pool = ThreadPool(processes=1) # start 4 worker processes result = pool.apply_async(f, [10]) # evaluate \"f(10)\" asynchronously print (result.get(timeout=1)) # prints \"100\" unless your computer is *very* slow t.timerStart() a = pool.map(f, range(10**6)) # prints \"[0, 1, 4,..., 81]\" t.timerEnd() 여기서 결과가 이상하다. 맥북 에어의 문제인지는 확인이 필요할 듯 12process=1# 0.329390287399292 sec elapsed 12process=20.35915374755859375 sec elapsed 12process=40.3417470455169678 sec elapsed https://gist.github.com/huklee/9685eba85d9cce172619bae14c9191c6 further questions프로세스를 늘려도 더 느려지기만 하지, 전혀 빨라지지 않는다. 너무 가벼운 연산이라 그런가? 아니면 context switching 하는 데 cost가 더 비싼 연산이라 그런가? CPU가 i5라서 문제인가? 현재 너무 많은 프로그램을 쓰고 있어서 memory가 딸려서 그런 문제인가? 다른 machine에서 돌려봐야 알 것 같다. using a pool of workers Mini mapreduce framework for pythonPool Example in this example, why is the code bad for parallel processing? Parallel MapReduce in Python in Ten Minutes Pydoop Google octopy useful linksIs there a simple Python map-reduce framework that uses the regular filesystem? Streaming mapreduce in Python a biginner’s guide on Hadoop by Matt. Rathbone MIT Big data 수업에서의 Mapreduce in Python on AWS","categories":[{"name":"python","slug":"python","permalink":"https://huklee.github.io/categories/python/"}],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"https://huklee.github.io/tags/Hadoop/"},{"name":"MapReduce","slug":"MapReduce","permalink":"https://huklee.github.io/tags/MapReduce/"}]},{"title":"github gurus","slug":"046.github-gurus","date":"2017-02-19T09:03:11.000Z","updated":"2017-02-19T09:42:47.000Z","comments":true,"path":"2017/02/19/046.github-gurus/","link":"","permalink":"https://huklee.github.io/2017/02/19/046.github-gurus/","excerpt":"","text":"Top usersJake Wharton #Java #Butter_knifehttps://github.com/JakeWharton Chris lattner #Swift #Applehttps://github.com/lattner Chris Banes #Java #Anroid #Palletehttps://github.com/chrisbanes Takayama Fumihiko #C++ #Karbinerhttps://github.com/tekezo Donne Martin #python #ipython #gitsome #sawshttps://github.com/donnemartin Kenneth Reitz #python #requests #python-guidehttps://github.com/kennethreitz Armin Ronacher (mitsuhiko) #python #flask #palletshttps://github.com/mitsuhiko Usefult linkspython git awardsJava git awardsjavascript git awards","categories":[{"name":"github","slug":"github","permalink":"https://huklee.github.io/categories/github/"}],"tags":[{"name":"python","slug":"python","permalink":"https://huklee.github.io/tags/python/"},{"name":"github","slug":"github","permalink":"https://huklee.github.io/tags/github/"},{"name":"gurus","slug":"gurus","permalink":"https://huklee.github.io/tags/gurus/"},{"name":"java","slug":"java","permalink":"https://huklee.github.io/tags/java/"}]},{"title":"Skia : 2D graphic library","slug":"045.Skia-2D-graphic-library","date":"2017-02-19T08:52:54.000Z","updated":"2017-02-19T08:56:03.000Z","comments":true,"path":"2017/02/19/045.Skia-2D-graphic-library/","link":"","permalink":"https://huklee.github.io/2017/02/19/045.Skia-2D-graphic-library/","excerpt":"","text":"SkiaSkibitmap overview안드로이드, 크롬에서 사용되는 google에서 support하는 2D graphic library이다. 주요 지원되는 파일 종류는 BMP, GIF, ICO, jpeg, png, bmp, ebp 등이다. Google에서 관리하고 운영되는 open source이다. Skia is an open source 2D graphics library which provides common APIs that work across a variety of hardware and software platforms. It serves as the graphics engine for Google Chrome and Chrome OS, Android, Mozilla Firefox and Firefox OS, and many other products.Skia is sponsored and managed by Google, but is available for use by anyone under the BSD Free Software License. While engineering of the core components is done by the Skia development team, we consider contributions from any source. Performance &amp; support방대한 그래픽 라이브러리라서 API 쓰는 방법 자체도 조금 만만치 않고, 일반 사용자용은 아닌 것으로 보인다. 대부분의 third-party가 native한 그래픽 decode library인 libpng, libjpeg, libwebp 등을 쓰고 있어서 성능은 거의 최강급으로 보인다. In skia/include/images/SkImageDecoder.h file, there is the image list decoding supported by Skia: 123456789101112enum Format &#123; kUnknown_Format, kBMP_Format, kGIF_Format, kICO_Format, kJPEG_Format, kPNG_Format, kWBMP_Format, kWEBP_Format, kLastKnownFormat = kWEBP_Format&#125;; 간단한 사용방법파일을 bitmap으로 최종변환하기 위해서는 내부적으로 정의된 SkBitmap 클래스를 사용해서 decoding을 해야 한다. 추후에 샘플 코드를 작성해서 올리도록 하겠다. Useful linksSkia Graphics Engine WikipediaSkia official pageSk codec test pageSkbitmap test page","categories":[{"name":"graphic","slug":"graphic","permalink":"https://huklee.github.io/categories/graphic/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://huklee.github.io/tags/C/"},{"name":"graphic","slug":"graphic","permalink":"https://huklee.github.io/tags/graphic/"}]},{"title":"Analytics services architecture","slug":"044.Analytics-services-architecture","date":"2017-02-18T08:37:52.000Z","updated":"2017-02-19T14:20:14.000Z","comments":true,"path":"2017/02/18/044.Analytics-services-architecture/","link":"","permalink":"https://huklee.github.io/2017/02/18/044.Analytics-services-architecture/","excerpt":"","text":"Useful links Architecture referencesGoogle Architecture Big Data Architecture Google Cloud Platform Architecture Analytical pipeline architecture All about Google Analytics Emerging Data Stack Hadoop Echo system VideosWhat is Google analytics?","categories":[{"name":"architecture","slug":"architecture","permalink":"https://huklee.github.io/categories/architecture/"}],"tags":[{"name":"architecture","slug":"architecture","permalink":"https://huklee.github.io/tags/architecture/"},{"name":"Big Data","slug":"Big-Data","permalink":"https://huklee.github.io/tags/Big-Data/"}]},{"title":"leetcode_validate-binary-search-tree","slug":"043.leetcode-validate-binary-search-tree","date":"2017-02-17T10:52:43.000Z","updated":"2017-02-17T11:25:39.000Z","comments":true,"path":"2017/02/17/043.leetcode-validate-binary-search-tree/","link":"","permalink":"https://huklee.github.io/2017/02/17/043.leetcode-validate-binary-search-tree/","excerpt":"","text":"leetcode problem solvinghttps://leetcode.com/problems/validate-binary-search-tree/ Following two solutions are simple to solve this problem. Solution A. BST should maintain the following features. for any node, all values of nodes in the left subtree should be smaller than the node. for any node, all values of nodes in the right subtree should be bigger than the node. Solution B. if the tree accepted following features, the maximum value of the left subtree is smaller than the parent node. the minimum value of the right subtree is bigger than the parent node. Solution A is the key idea of latter solution with child comparison.Solution B is the key idea of former solution with root comparison. Here’s my C++ implementations of the solutions. Min / Max validation with root comparison O(n)12345678910111213141516171819202122232425262728293031323334353637383940414243// ======================= Root comparison approach ============================class BSTinfo&#123;public: bool isValid; int maxVal; int minVal; BSTinfo(bool is, int minV, int maxV) : isValid(is), maxVal(maxV), minVal(minV)&#123;&#125;;&#125;;BSTinfo isValidBSTinfo(TreeNode* root)&#123; // 00. edge &amp; base cases if (root == nullptr) return BSTinfo(true, -1, -1); if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) return BSTinfo(true, root-&gt;val, root-&gt;val); // 01. in case one subtree is a leaf node if (root-&gt;left == nullptr)&#123; BSTinfo rInfo = isValidBSTinfo(root-&gt;right); if (rInfo.isValid &amp;&amp; root-&gt;val &lt; rInfo.minVal) return BSTinfo(true, root-&gt;val, rInfo.maxVal); return BSTinfo(false, -1, -1); &#125; if (root-&gt;right == nullptr)&#123; BSTinfo lInfo = isValidBSTinfo(root-&gt;left); if (lInfo.isValid &amp;&amp; lInfo.maxVal &lt; root-&gt;val) return BSTinfo(true, lInfo.minVal, root-&gt;val); return BSTinfo(false, -1, -1); &#125; // 02. other cases BSTinfo lInfo = isValidBSTinfo(root-&gt;left); BSTinfo rInfo = isValidBSTinfo(root-&gt;right); if (lInfo.isValid &amp;&amp; rInfo.isValid)&#123; if (lInfo.maxVal &lt; root-&gt;val &amp;&amp; root-&gt;val &lt; rInfo.minVal) return BSTinfo(true, lInfo.minVal, rInfo.maxVal); &#125; return BSTinfo(false, -1, -1);&#125;bool isValidBST(TreeNode* root) &#123; return isValidBSTinfo(root).isValid;&#125; Min / Max validation with child comparison O(n)123456789101112131415161718192021// ======================= Child comparison approach ===========================bool isValidBST_(TreeNode* pNode, TreeNode* minNode, TreeNode* maxNode)&#123; // 00. base case if (pNode == nullptr) return true; // 01. edge cases : in case one subtree is invalid bool isLeftInvalid = minNode &amp;&amp; minNode-&gt;val &gt;= pNode-&gt;val; bool isRightInvalid = maxNode &amp;&amp; maxNode-&gt;val &lt;= pNode-&gt;val; if (isLeftInvalid || isRightInvalid) return false; // 02. other cases bool isLeftValid = isValidBST_(pNode-&gt;left, minNode, pNode); bool isRightValid = isValidBST_(pNode-&gt;right, pNode, maxNode); return isLeftValid &amp;&amp; isRightValid;&#125;bool isValidBST(TreeNode* root) &#123; return isValidBST_(root, nullptr, nullptr);&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/categories/algorithm/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://huklee.github.io/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://huklee.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/tags/algorithm/"},{"name":"array","slug":"array","permalink":"https://huklee.github.io/tags/array/"}]},{"title":"hexo visitor counter","slug":"042.hexo-visitor-counter","date":"2017-02-16T14:59:30.000Z","updated":"2017-02-16T15:17:56.000Z","comments":true,"path":"2017/02/16/042.hexo-visitor-counter/","link":"","permalink":"https://huklee.github.io/2017/02/16/042.hexo-visitor-counter/","excerpt":"","text":"Useful linksbunsanzi visitor countertea3 popular postsissan hexo theme","categories":[{"name":"draft","slug":"draft","permalink":"https://huklee.github.io/categories/draft/"}],"tags":[{"name":"draft","slug":"draft","permalink":"https://huklee.github.io/tags/draft/"}]},{"title":"branch and bound algorithm","slug":"041.branch-and-bound","date":"2017-02-16T12:23:51.000Z","updated":"2017-02-16T15:18:40.000Z","comments":true,"path":"2017/02/16/041.branch-and-bound/","link":"","permalink":"https://huklee.github.io/2017/02/16/041.branch-and-bound/","excerpt":"","text":"Branch and boundNP-Hard 등의 문제를 풀 때, 가지치기를 효과적으로 하며 최적의 해를 탐색하는 기법 중 하나. Branch별로 Bound와 탐색 중에 발견된 Maxprofit을 비교하여 Prunning을 하는 기법이다. 즉, branch별로 선택하는 경우에 대한 Bound (주어진 상황에서 예상되는 최대의 결과)를 계산하여 이를 선택의 제외의 기준으로 삼는 방법이다. 처음에 이해하기는 조금 헷갈리는 개념이지만, 실제로 그림을 그리면서 진행해보면 생각만큼 이해하기는 어렵지 않은 주제이다. TSP를 예를 들어서, 남은 선택 중에서 모두 최선의 선택을 한다고 가정할 경우에 나오는 예상 값을 각각 bound로 계산한다. TSP의 목표는 탐색비용의 최소화이므로, bound는 lower bound가 될 것이다. 탐색을 하면서 각 branch별로 bound를 먼저 계산하고 가장 bound가 낮은 것부터 탐색한다. 순회를 계속해 진행하면서 maxprofit을 갱신해 나간다. maxprofit보다 bound가 높은 node의 경우는 더 이상 진행할 필요가 없으므로 추가로 탐색하지 않는 것을 반복한다. 끝. 간단하면서도 효과가 뛰어난 NP-Hard 해결 방법 중 하나이다. best-first search 방법을 섞어서 사용하면 조금 더 탐색의 효율이 개선될 것으로 보인다. 검증할 필요는 있어 보이지만.. 문제구현Useful linksBranch and bound in TSP Branch and bound in knapsack Best-first search : greedy BFS in knapsack Sahaj Computer Solutions : backtracking @ knapsack problem","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/tags/algorithm/"},{"name":"draft","slug":"draft","permalink":"https://huklee.github.io/tags/draft/"},{"name":"NP-Hard","slug":"NP-Hard","permalink":"https://huklee.github.io/tags/NP-Hard/"},{"name":"TSP","slug":"TSP","permalink":"https://huklee.github.io/tags/TSP/"}]},{"title":"algorithm test guides","slug":"040.algorithm-test-guides","date":"2017-02-16T06:53:11.000Z","updated":"2017-02-16T15:20:19.000Z","comments":true,"path":"2017/02/16/040.algorithm-test-guides/","link":"","permalink":"https://huklee.github.io/2017/02/16/040.algorithm-test-guides/","excerpt":"","text":"알고리즘 문제 제대로 잘 풀기삼성 SW 검정시험(Certificate Test) 가이드 (Professional, Expert)약 12년 동안 알고리즘 문제풀이 강사를 하였고, 삼성전자 인재개발원에서도 강의를 오랫동안 하고 계신 장홍준님의 문제풀이 팁. 간단히 요약을 하자면 다음과 같다. 알고리즘 문제를 잘 풀 수 있는 실력 늘리기 기초적인 알고리즘에 대한 깊은 이해가 필요 다양한 문제를 풀어보고, 실제로 코딩을 진행해야 함 알고리즘의 뛰어난 구현능력을 갖추어야 함. 구체적으로는 다음 세 가지를 갖추어야 함. 정확한 코드 수행시간이 짧도록 빠르게 구현하는 능력특히나 정확한 코드 구현 능력이 중요하다. 빠르게 구현하는 능력보다 디버깅 시간을 줄이는 것이 효과적이기 떄문이다. 알고리즘 시험을 잘 보는 방법 문제를 정확히 잘 읽어야 한다. 할 수 있는 한 끝까지 최선을 다해야 한다. 문제에서 놓친 것은 없는 지 꼼꼼하게 확인해야 한다. 테스트 케이스를 여러가지로 만들어서 끝까지 edge cases를 파악해야 한다. 이전에 풀었던 문제 혹은 알고리즘에 끼워맞추거나 기억을 더듬어 풀으려 하지 말라. Useful links프로그램을 배웠으나 알고리즘 시험을 봐야 한다면 10편 프로그램을 배웠으나 알고리즘 시험을 봐야 한다면 9편 프로그램을 배웠으나 알고리즘 시험을 봐야 한다면 8편 프로그램을 배웠으나 알고리즘 시험을 봐야 한다면 7편 프로그램을 배웠으나 알고리즘 시험을 봐야 한다면 6편 프로그램을 배웠으나 알고리즘 시험을 봐야 한다면 5편 프로그램을 배웠으나 알고리즘 시험을 봐야 한다면 4편 프로그램을 배웠으나 알고리즘 시험을 봐야 한다면 3편 프로그램을 배웠으나 알고리즘 시험을 봐야 한다면 2편 프로그램을 배웠으나 알고리즘 시험을 봐야 한다면 1편","categories":[{"name":"Tips","slug":"Tips","permalink":"https://huklee.github.io/categories/Tips/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/tags/algorithm/"},{"name":"problem solving","slug":"problem-solving","permalink":"https://huklee.github.io/tags/problem-solving/"}]},{"title":"1st Deepcon.info Day 2 @ Seoul","slug":"039.1st-Deepcon-info-Seoul-2nd-Day","date":"2017-02-16T02:39:45.000Z","updated":"2017-02-17T07:27:24.000Z","comments":true,"path":"2017/02/16/039.1st-Deepcon-info-Seoul-2nd-Day/","link":"","permalink":"https://huklee.github.io/2017/02/16/039.1st-Deepcon-info-Seoul-2nd-Day/","excerpt":"","text":"제1회 딥러닝 컨퍼런스 2017 2일차주최 : 서형석 대표 @ 딥러닝그룹 1. Up and Running with Tensorflow : 박규병 카카오 브레인 연구원Up and running with Tensorflowtensorflow-exercises We will Cover basic usage of Tensorflow. the most important functions, focusing on the comparison with NumPy. programming a simple regression task with Tensorflow. some of basic neural network theories. We will NOT cover how to install Tensorflow. deep understanding of deep learning. serious implementation with real problemsRequirements Basic familiarity with Python and NumPy Bring your own laptop where Tensorflow, NumPy, and IPython have been installed. Deep learning background will be more than welcome, but not required. 주요 연구분야 및 관심사 수학 / 언어 관련 github: sudoku github: neural Chinese translator github: neural Japanese translator TutorialsNumpy exercises Deep learning을 다루면서 맞닥트리는 요소들 Mathematical background (statistics, probabilities, linear algebra) NN Theories (Back-propagation, activation, normalization…) Speed of progression 너무 빠르게 기술이 발전하고 있는 분야라는 것은 부담스럽다. Programming skills (Python, NumPy, TensorFlow, Theano…) English (lecture listening, paper reading, reference…) Money (GPUs) 제대로 deep learning을 할 수 있는 역량을 기르려면 6개월 정도는 머리 싸매고 고생한다고 생각해야 제대로 어느 정도 다룰 수 있는 역량에 도달할 수 있다고 생각해야 한다. basic terms @ TensorFlow TensorFlow is a programming system in which you represent computations as graphs. Nodes in the graph are called Ops (abbr. for operations) An op takes zero or more Tensors, performs computations and produces zero or more Tensors. a Tensor is a typed multi-dimensional array. a TensorFlow graph is a description of computations. a graph MUST be launched in a session, then put into devices, such as CPUs or GPUs. these methods return tensors produced by ops as numpy.ndarrays. you can think of a tensor as an n-dimension array, Tips 단순한 예제를 따라하는 데 있어서는 세부적인 tensorflow사용법이 중요하지 않을 수 있다. 하지만, 깊게 deep learning 알고리즘을 적용한다면 이런 기초가 매우 필수적이다. 실제적인 product를 만들려고 한다면 jupyter를 사용하지 않고, IDE를 사용하는 것을 추천합니다. 생각보다 프로그램을 돌리기에 버그도 많고, 디버깅이 쉽지 않다. 기본적으로 np.array를 쓸 때는 dtype을 명확하게 명시해 주는 습관을 주는 것이 좋다. 12345# Good examplex = np.array([1,2], dtype=np.int64)# Bad exampley = np.array([1,2]) tensor를 다루면서 가장 중요한 개념 중 하나가 shape, dtype이다. 제대로 된 결과가 나오는 지를 알기 위해서 값보다는 위의 두 속성들을 유심히 살펴보자. 12345_x = [[1,2], [3,4]]x = tf.convert_to_tensor(_x)print(x)# Tensor(\"Const_3:0\", shape=(2, 2), dtype=int32) 2. Deep learning and Speech recognition - 육동석 : 교려대학교History of AI, especially neural networks Neural Network의 태동기 (1950s) The Perceptron: A Probabilistic Model For Information Storage And Organization In The Brain, Rosenblatt, 1958 Perceptron이 처음으로 소개되었으며, 인간의 뇌와 비슷한 뉴런구조에 기반한 패턴인식 알고리즘가 소개되고 발전됨 Neural Network의 침체기 (1960~70s) An Introduction to Computational Geometry, Minsky &amp; Papert, 1969 낮은 성능과 당시의 컴퓨팅 파워로는 제대로 된 계산이 불가능함을 깨달음 Neural Network의 제2번성기 (1980s) Parallel Distributed Processing: Explorations in the Microstructure of Cognition, Rumelhart, 1986 Back-propagation을 통한 neural network의 성능 개선 Gradient-based learning applied to document recognition, Lecun, 1989 MNIST 문제의 해결을 CNN이라는 개념을 처음 도입하여 해결 Neural Network의 제2침체기 (1990s) 별다른 발전 없이 SVM를 포함한 다른 machine learning들에 비해 발전이 더뎠음 Neural Network의 최대 번성기 : Neural Network의 재발견과 Deep learning의 발전 (2000s ~ ) Contrastive divergence learning, Hinton 2002 음성 인식의 발전 1980년대의 hidden markov 모델이 현재에도 time-series sequence에서도 적용이 비교적 효과적인 모델 중 하나이다. Deep neural network의 도입에 따라 guassian distribution 모델을 대체하여, DNN(RNN + LSTM)이 큰 성능의 향상을 가져왔다. The neural networks behind Google Voice transcription 3. 자연언어처리에서의 Deep learning - 권혁철 : 부산대학교자연언어처리의 4대 요소기술 형태소 분석 Morphological segmentation 통사 분석 Syntactic analysis 의미 분석 Semantic analysis 어려움 : 어의 중의성 word sense disambiguation 화용 분석 Pragmatic Analysis 자연언어처리 응용기술 기계번역 (machine translation) 정보검색 (information search) 질의응답 (query retrieval) 음성인식 (speech recognition) 음성합성 (speech composition) 문서축약 맞춤법/문법 검사 TutorialsHuklee’s tensorflow Tutorials Tensorflow variables Tensorflow Ex0.Grpah Tensorflow Ex1.Variables Tensorflow Ex2.Placeholders Tensorflow Ex3.Linear Regression Useful linksTensorFlow tutorialsTensorFlow basic usagesArtificial Neural Network : WikipediaThe neural networks behind Google Voice transcription","categories":[{"name":"Conference","slug":"Conference","permalink":"https://huklee.github.io/categories/Conference/"}],"tags":[{"name":"Deep learning","slug":"Deep-learning","permalink":"https://huklee.github.io/tags/Deep-learning/"},{"name":"Machine learning","slug":"Machine-learning","permalink":"https://huklee.github.io/tags/Machine-learning/"}]},{"title":"1st Deepcon.info Day 1 @ Seoul","slug":"038.1st-Deepcon-info-Seoul-1st-Day","date":"2017-02-16T01:47:11.000Z","updated":"2017-02-17T06:30:17.000Z","comments":true,"path":"2017/02/16/038.1st-Deepcon-info-Seoul-1st-Day/","link":"","permalink":"https://huklee.github.io/2017/02/16/038.1st-Deepcon-info-Seoul-1st-Day/","excerpt":"","text":"제1회 딥러닝 컨퍼런스 2017 1일차주최 : 서형석 대표 @ 딥러닝그룹 1. 베이지안 딥러닝 - 김용대 : 서울대학교 통계학과slides IntroBayesian에 전반적인 내용을 다룰 예정. 끝 부분에서 베이지안 딥러닝에 대해서 언급하고 발표를 마칠 예정임. 사후분포Posterior distribution는 우도함수Likelihood function 과 사전분포Prior distribution의 곱에 비례한다. 시간에 따라서 분포가 변하는 상황에 대해서 bayesian 접근은 꽤나 좋은 접근방식이 될 수 있다. 장점 : prediction의 정확도가 매우 높은 편 / Uncertainty quantization 불확실성에 대한 확률을 계산하기 좋다 단점 : computation is hard / Need full observation of distribution Bayesian computation크게 세 가지로 나누어진다. 손으로 구하기 / monte-carlo 사용하기 / approximation 사용하기 (나머지 3개) Analytical approaches with conjugate priors Monte-Carlo method Variational Inference Assumed Density Filtering Expectation Propagation assume density의 확장판 Deep learning with bayesian 모델시작한 지 얼마 되지 않아서 아직 가시적인 연구결과에 대해서는 적용된 것이 없다. 딥러닝의 여러 가지 아키텍쳐 deep neural network deep belief network / deep boltzmann machine stack encoder 실제로는 deep neural network만 사용되고 나머지는 참고로만 알아두면 된다. 주로 CNN, RNN이 사용된다는 것마 알아두면, 상관없다. Deep latent gaussian model (DLGM)Probabilistic Neural Network Models 둘 다 모두 수학적으로 엄청나게 어려운 계산이 들어가는 부분이라 이해하고 사용하기가 쉽지 않다. approximation을 하는 방법이 다양하게 가능하다. 2. deep generative model 관련 최근 연구들 - 신진우 : KAIST 전기전자Recent trends classification : CNN natural language process : RNN Generative deep learning Application : image regeneration &amp; recommendation example generate a image for the style of artist making a 복원된 image image compression Part I : graphical model approach Markov random field, restricted Boltzmann machine Approach Gibbs distribution MRF(Markov Random Field) / RBM(Restricted Boltzmann Machines) / DBM(Depp Boltzmann Machines): two-state markov state Part II : Neural network approach de-noising auto-encoder, variational auto-generator 가장 Hot한 토픽 논문 Generatvie adversarial Network (GAN) [Goodfellow et al.2014] Deep convolutional GAN [radford et al. 2015] Game and decision making deep reinforcement learning Research in agorithmic intelligence lab image compression via neural networks jpeg을 뛰어 넘는 그림 압축 알고리즘 만들어내기 : rate 120 굉장히 의미 있는 가시적 결과가 나오고 있음 NP-Hard 문제 도전하기 : TSP 문제 Lab 서버 운영 Lab에서 사용하고 있는 GPU 서버 50대 운영 : Titan X 유명한 해외 Lab은 100대 정도는 돌리는 경우도 많다고 함 3. Building Deep Learning - 김인중 : 한동대학교A Review of a Neural Network algorithmsvector형태로 표현할 수 있는 모든 데이터는 Neural Network의 입력, 혹은 출력으로 사용될 수 있다. Implmentation of Neural NetworkC++로 구현한 HGU Neural Network Deep learning algorithms on GPU 특징 GPU 특성상 ALU가 수백개에서 수천개를 내부에 가지고 있다. 성능 일반적으로는 딥 러닝 알고리즘을 적용할 때 CPU에 비해서 이미지 인식은 60배 정도 빠르며, training을 하는 데 있어서는 20배 정도 성능의 차이가 난다. 주의할 점 parallel하게 연산을 처리할 수 있는 상황이 아니라면 오히려 CPU보다 연산이 느릴 수도 있는 상황이 존재할 수 있으니 주의해야 한다. Neural Networks Demonstration on XOR 직접 소스코드를 짜 보면, 많으 부분 deep learning에 대한 이해도가 높아진다. learning rate은 왠만하면 작게 하는 게 좋음 (0.001 정도) Generated Neural Networks ex&gt; autoencoder, restricted Boltzmann Machines generated같은 경우는 원래 자신의 형태를 다시 만들어야 하는 constraint를 가지고 있다. 따라서 hidden layer가 일반적인 NN에 비해서 많이 가지고 있게 된다. generated가 일반적인 NN 보다는 훨씬 어려운 문제를 다루고 있다고 볼 수 있으며, 응용할 수 있는 분야도 많다고 볼 수 있다. Restricted Boltzmann Machines : RBM 역시 양방향 네트워크의 특성을 가지고 있음. energy function + sigmoid function으로 표현됨 RBM input / output RBM probability functions RNN : Recurrent Neural NetworkMain features RNNs are Turing-complete sequence to sequence mapping best approach to following problems Speech recognition skype translation (error rate goes 45% -&gt; 17%:LSTM) handwriting recognition machine translation problems in RNN vanishing gradient problems long term dependency의 문제가 있음 But, LSTM approach solved this problem 더 자세한 설명은 다음 참고 Understanding LSTM RNN Practical Advices deep learning을 제대로 이해하는 데 있어서 실제로 알고리즘의 내부를 실제로 코딩을 하는 것을 크게 추천한다. 하지만, 굉장히 복잡한 작업이며, 특히나 CNN, RNN 등은 그 복잡도가 엄청 어렵다. Theory를 완전히 이해해야만 수식을 하나하나 되집어 가면서 봐야만 한다. 특히 GPU는 fault tolerant한 특성을 가지고 있기 떄문에, 디버깅이 매우 힘든 프로그래밍 중 하나이다. 따라서, 디버깅 툴인 trace 등을 통해서 제대로 잡히지 않는 경우가 허다하다. 디버거를 통하지 않고, trace &amp; watch만으로는 힘든 부분이 있어서, 머리로 모든 알고리즘의 로직을 완성하고, 디버깅을 수행하기를 추천함. CPU 알고리즘을 먼저 구현하고, 그 다음에 GPU 알고리즘을 구현하는 것을 추천함. Q &amp; AUseful Links모두를 위한 머신러닝/딥러닝 - 김성훈 교수Deep Learning Research Blog by Andrej KarpathyUnderstanding LSTM RNNBack-propagation algorithm for MLP, CNN, RNN by 김수형 전남대 교수","categories":[{"name":"Conference","slug":"Conference","permalink":"https://huklee.github.io/categories/Conference/"}],"tags":[{"name":"Deep learning","slug":"Deep-learning","permalink":"https://huklee.github.io/tags/Deep-learning/"},{"name":"Machine learning","slug":"Machine-learning","permalink":"https://huklee.github.io/tags/Machine-learning/"}]},{"title":"light web-based coding tools","slug":"037.light-web-based-coding-tools","date":"2017-02-12T14:33:47.000Z","updated":"2017-02-12T14:49:41.000Z","comments":true,"path":"2017/02/12/037.light-web-based-coding-tools/","link":"","permalink":"https://huklee.github.io/2017/02/12/037.light-web-based-coding-tools/","excerpt":"","text":"Light web-based coding toolsWandbox사용에 제한이 없는 web-based coding open source툴. 간단한 C++는 잘 돌아가는 것을 확인헀는데, python은 동작이 제대로 안 돌아가는 것 같다. 아직 구현이 덜된건가? 여튼 C, C++를 간단히 테스트하기에는 무척이나 유용한 툴http://melpon.org/wandbox coderpad깔끔하고 사용하기 좋아보이는 coderpad. 상용 툴이라서 제한은 좀 있지만 정말 간단하게 코드를 웹에서 테스트해보기 딱 좋다. 다만, 로그인하지 않으면 곧 expire되므로, 유료사용자가 될 것이 아니면 제약이 많다.https://coderpad.io/ 지원 가능 언어들 : 거의 모든 언어가 다 된다고 보면 된다. C C# C++ Clojure CoffeeScript Erlang F# Go Haskell Java JavaScript Markdown MySQL Objective-C PHP Perl Plain Text Python 2 Python 3 R Ruby Rust Scala SwiftVisual Basic","categories":[{"name":"Tips","slug":"Tips","permalink":"https://huklee.github.io/categories/Tips/"}],"tags":[{"name":"programming","slug":"programming","permalink":"https://huklee.github.io/tags/programming/"}]},{"title":"SOLID Design principles by GoF","slug":"036.SOLID-Design-principles","date":"2017-02-10T14:01:06.000Z","updated":"2017-02-11T00:05:14.000Z","comments":true,"path":"2017/02/10/036.SOLID-Design-principles/","link":"","permalink":"https://huklee.github.io/2017/02/10/036.SOLID-Design-principles/","excerpt":"","text":"SOLID Design principles by GoFThere are five well-known software design principles from the book “Head First, Design Patterns”. Nothing’s absolute, but classical things are great enough to know and have a look on it. S : Single responsibilityO : OCP, Open / Close Principles Objects should be open for extension, but closed for modification. 클래스(객체)는 확장에 대해서는 열려있어야 한다. 하지만, 코드 변경에 대해서는 닫혀 있어야 한다. LID : Dependency Inversion Principles if you want an easier life as a coder, “depend on abstractions, not concretions” 추상화된 것에 의존하도록 만들어라. 구상 클래스에 의존하도록 만들지 않아야 한다. Useful linksSOLID design principles","categories":[{"name":"programming","slug":"programming","permalink":"https://huklee.github.io/categories/programming/"}],"tags":[{"name":"design patterns","slug":"design-patterns","permalink":"https://huklee.github.io/tags/design-patterns/"}]},{"title":"traverse algorithms","slug":"035.traverse-algorithms","date":"2017-02-07T07:47:02.000Z","updated":"2017-02-10T14:00:18.000Z","comments":true,"path":"2017/02/07/035.traverse-algorithms/","link":"","permalink":"https://huklee.github.io/2017/02/07/035.traverse-algorithms/","excerpt":"","text":"Backtracking 특징 주로 재귀호출 사용 tree traverse, 특히 state tree traverse 문제의 해결방법 모든 가능성을 뒤져보는 행위 : 느릴 수 밖에 없음 보통 지수함수 이상의 time complexity를 가진다 가지치기 (Prunning)을 사용하면 효과의 향상을 가져올 수 있음 (DFS와의 차이) rough implementation 123456789101112# recursivedef backtracking (candidate): # 01. Reject or accept answer = [] if isReject(candidate) return [] if isAccept(candidate) answer.append(candidate) # 02. Recursive call subProblem = getFirstChild(candidate) while isValid(subProblem): answer += backtracking(subProblem) subProblem = getNextChild(candidate) return answer DFS 특징 recursive / iterative 둘 다 구현 가능 iterative하게 구현할 경우 stack을 써서 candidate 관리 Time complexity : O(V + E) Space complexity : O(V) rough implementation () 1234567891011121314# recursivedef dfs(graph, start, visited=None): # 01. check visit status if visited == None: visited = set() visited.add(start) # 02. do something with the start vertex doSomething(start) # 03. recursive call candidates = [v for v in grpah.getAdj(start) if isVisited(v)] for v in candidates: dfs(graph, v, visited) BFS 특징 candiate을 queue로 구현함 iterative하게 구현해야함 (recursive로는 어려움) Time complexity : O(V + E) Space complexity : O(V) rough implementation 123456789101112131415# iterativedef bfs(graph, start): # 01. initialization visited, queue = set(), [start] while queue != []: # 02. do something with the start vertex doSomething(start) # 03. find the candidates candSet = [v in graph.getAdj(start)] for cand in candSet: if isVisited(v) in not visited: queue.append(v) queue.pop(0) Shortest path finding in graph dijkstra algorithm Bellman-ford algorithm A* search Useful linksBacktracking in Wikipedia BFS &amp; DFS in python Depth first search Breadth first search","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/tags/algorithm/"},{"name":"tree","slug":"tree","permalink":"https://huklee.github.io/tags/tree/"},{"name":"graph","slug":"graph","permalink":"https://huklee.github.io/tags/graph/"}]},{"title":"Installing Tensorflow using virtualenv on Mac","slug":"034.Installing-Tensorflow-using-virtualenv-on-Mac","date":"2017-02-07T04:00:18.000Z","updated":"2017-02-07T04:25:16.000Z","comments":true,"path":"2017/02/07/034.Installing-Tensorflow-using-virtualenv-on-Mac/","link":"","permalink":"https://huklee.github.io/2017/02/07/034.Installing-Tensorflow-using-virtualenv-on-Mac/","excerpt":"","text":"Installing tensorflow using virtualenv on Mac이전 포스트에서 Anaconda를 사용하여 설치를 했더니, jupyter에서 제대로 tensorflow와 conda env를 인식하지 못 하는 문제가 발생했다. 이래저래 많이 헤매었는데, 정답은 virtualenv와 pip를 사용하는 것이 가장 깔끔했다. 이번 포스트에서는 virtualenv + pip (python3)를 활용한 설치로 진행한다. 아나콘다는 싹 밀어버리고 진행한다. Environment &amp; prerequisites Mac air i5 1.5Ghz, 8G ram OS X Sierra 10.12.3 homebrew Installation target python 3.6.0 pip 9.0.1 tensorflow 0.9.0 etc (numpy, scipy, scikit-learn … ) Install steps 파이썬 3를 설치하자. pip3를 사용해서 설치를 하려면 기본적으로 깔아야 한다. 1$ brew install python3 다음으로는 virtualenv를 설치하자 1$ pip3 install --upgrade virtualnev 지정된 폴더에 virtualenv 설정을 새로 만들고 적용하자. activate를 해주면 다음과 같이 shell prompt 에 (tensorflow)가 붙는 것을 확인할 수 있다. 123$ virtualenv --system-site-packages ~/Work/tensorflow$ source ~/Work/tensorflow/bin/activate(tensorflow) $ tensorflow를 설치하자. pip 로 설치하며, os에 맞는 url을 설정해주고 설치를 진행하면 된다. 12(tensorflow) $ export TF_BINARY_URL=https://storage.googleapis.com/tensorflow/mac/tensorflow-0.9.0-py3-none-any.whl(tensorflow) $ pip3 install --upgrade $TF_BINARY_URL tensorflow가 잘 실행되는 지 테스트해보자. 앞에서 했던 대로 테스트해보면 된다. sample code 1234567import tensorflow as tfhello = tf.constant('Hello, TensorFlow!')sess = tf.Session()print(sess.run(hello))a = tf.constant(10)b = tf.constant(32)print(sess.run(a + b)) expected result b’Hello, TensorFlow!’ 42 추가로 필요한 패키지들을 pip로 설치해야 한다. scipy, numpy, jupyter 등을 설치해야 한다. 한번에 \u001apip 한 방으로 설치하면 편하다. 12(tensorflow) $ python3 -m pip install --upgrade pip(tensorflow) $ pip3 install --user numpy scipy matplotlib ipython jupyter pandas sympy nose 추가로 path를 추가해야 한다. 다음과 같이 export로 실행파일들이 있는 user의 실행파일 폴더를 추가하자. tensorflow virtualenv를 실행하면 자동으로 추가하기 위해서는 해당 activate script 중간에 추가하자. 1$ export PATH=\"$PATH:/Users/huklee/.local/bin\" scikit-learn 설치추가로 scikit-learn을 아래와 같이 설치하자. 마찬가지로 virtualenv로 들어와 있는 상태에서 진행해야 제대로 tensorflow 환경이 반영될 수 있다. 1(tensorflow) $ pip3 install -U scikit-learn jupyter notebook 실행jupyter notebook을 실행하자. 마찬가지로 tensorflow virtualenv를 실행시킨 상태에서 실행이 되어야 한다. 그리고 나서는 브라우저(chrome)으로 http://localhost:8888/ 에 접속하면 된다. 1(tensorflow) $ jupyter notebook DONE여기까지 하면 jupyter에서 tensorflow 및 scikit-learn, numpy, scipy, pandas 몽땅 잘 작동하는 것을 확인할 수 있다. Useful links이승철 교수님 강의 machine learning 관련 python코드 Anaconda: conda package manage How to check python’s version in running python how to uninstall Anaconda on Mac Jupyter notebook and conda Scikit-learn install tensorflow 튜토리얼","categories":[{"name":"Data Science","slug":"Data-Science","permalink":"https://huklee.github.io/categories/Data-Science/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://huklee.github.io/tags/Mac/"},{"name":"python","slug":"python","permalink":"https://huklee.github.io/tags/python/"},{"name":"Data","slug":"Data","permalink":"https://huklee.github.io/tags/Data/"},{"name":"Deep learning","slug":"Deep-learning","permalink":"https://huklee.github.io/tags/Deep-learning/"}]},{"title":"Ubuntu TIps : Ubuntu Desktop certified hardware","slug":"033.Ubuntu-TIps-Ubuntu-Desktop-certified-hardware","date":"2017-02-06T07:43:10.000Z","updated":"2017-02-06T07:46:54.000Z","comments":true,"path":"2017/02/06/033.Ubuntu-TIps-Ubuntu-Desktop-certified-hardware/","link":"","permalink":"https://huklee.github.io/2017/02/06/033.Ubuntu-TIps-Ubuntu-Desktop-certified-hardware/","excerpt":"","text":"Ubuntu 에 맞는 노트북 혹은 데스크탑 맞출 때 확인다음 사이트에서 지원되는 하드웨어인지를 확인한 후에 구입을 하도록 하자. 랩탑을 사든, 데스크탑을 사든, 참조해서 진행해야 제대로 된 성능을 낼 수 있는 드라이버를 찾는 데 문제가 없을 것 같다.Ubuntu Desktop certified hardware","categories":[{"name":"Tips","slug":"Tips","permalink":"https://huklee.github.io/categories/Tips/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://huklee.github.io/tags/Ubuntu/"},{"name":"Linux","slug":"Linux","permalink":"https://huklee.github.io/tags/Linux/"}]},{"title":"install Tensorflow on Mac air","slug":"032.install-Tensorflow-on-Mac-air","date":"2017-02-06T00:58:31.000Z","updated":"2017-02-17T07:14:03.000Z","comments":true,"path":"2017/02/06/032.install-Tensorflow-on-Mac-air/","link":"","permalink":"https://huklee.github.io/2017/02/06/032.install-Tensorflow-on-Mac-air/","excerpt":"","text":"Installing Tensorflow on Mac airtensorflow를 설치하는 방법에는 다음과 같이 다섯 가지 방법이 있다. 이 중에는 일단 가장 익숙한 Anaconda를 사용한 설치 방법을 따라가 보도록 하자. 주의할 점 현재 conda를 활용한 설치에서는 일단 CPU만을 사용하는 tensorflow만 가능하다. GPU를 사용할 수 있게 하기 위해서는 cuda 설치 + pip로 tensorflow 설치 하는 두 가지 과정이 포함되어야 한다. Anaconda 4.2 버전을 사용하는 것을 추천한다. 아직 4.3이상의 버전에서는 tensorflow와 이래저래 충돌하는 문제가 있는 것으로 알려져 있다. 윈도우에서도 Anaconda 4.2를 사용하여 진행하면 비슷한 방법으로 진행이 가능하다고 하니 참고하도록 하자. 1. Anaconda 다운로드 받기아래 링크에서 Anaconda를 다운받아서 설치하자. python 3.6 CLI install 버전을 다운 받아서 진행했다.Anaconda download for Mac 다운로드 받은 폴더에서 다음과 같이 설치하자. 1$ source Anaconda3-4.3.0-MacOSX-x86_64.sh 쭉 yes / enter를 해 주면 설치가 5~10분 정도 걸린다. 다운로드 및 설치 당시 파일 기준의 버전은 아래와 같다. 1234$ python -V Python 3.6.0 :: Anaconda 4.3.0 (x86_64)$ conda -V conda 4.3.8 다음과 같이 conda envinronment에 텐서플로우를 추가하자. 1$ conda create -n tensorflow python=3.4 추가된 conda environment를 사용하기 위해서는 source activate [env_name] 을 사용해서 접속하면 된다. 활성화된 conda env에서 실제로 python 버전을 찍어보면 다른 버전이 나오는 것을 확인할 수 있다. 반대로 env를 나오기 위해서는 source deactivate로 나오면 된다. 12345$ python -VPython 3.6.0 :: Anaconda 4.3.0 (x86_64)$ source activate tensorflow$ (tensorflow) python -VPython 3.4.5 :: Continuum Analytics, Inc. 2. install tensorflow본격적으로 tensorflow를 설치하자. 위에서 바로 실행된 conda env가 activate된 상태에서 진행하면 된다. pip 12# should be on conda env$ (tensorflow) conda install -c conda-forge tensorflow 3. test tensorflow다음과 같은 샘플 코드를 한 번 돌려보자. 결과가 다음과 같이 나오면 성공! sample code 1234567import tensorflow as tfhello = tf.constant('Hello, TensorFlow!')sess = tf.Session()print(sess.run(hello))a = tf.constant(10)b = tf.constant(32)print(sess.run(a + b)) expected result b’Hello, TensorFlow!’ 42 추가로 예제를 돌려보기 위해서 다음 github에서 tensorflow 예제를 clone해서 가져오도록 하자. 1$ git clone https://github.com/tensorflow/tensorflow Useful linksenable GPU support anaconda tensorflow installation tensorflow Korea gitbook","categories":[{"name":"Data Science","slug":"Data-Science","permalink":"https://huklee.github.io/categories/Data-Science/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://huklee.github.io/tags/Mac/"},{"name":"python","slug":"python","permalink":"https://huklee.github.io/tags/python/"},{"name":"Data","slug":"Data","permalink":"https://huklee.github.io/tags/Data/"},{"name":"Deep learning","slug":"Deep-learning","permalink":"https://huklee.github.io/tags/Deep-learning/"}]},{"title":"Time complexity notations","slug":"031-Time-complexity-notations","date":"2017-02-04T07:57:13.000Z","updated":"2017-02-05T06:11:25.000Z","comments":true,"path":"2017/02/04/031-Time-complexity-notations/","link":"","permalink":"https://huklee.github.io/2017/02/04/031-Time-complexity-notations/","excerpt":"","text":"Time complexity notationsSometimes complexed about the exact meaning of the Big-O, theta, and omega notations. I found a great and beautiful summary table of them. For more details, check out the wikipedia pages below. UsefulAlgorithm Time complexity : Family of Bachman Landau notations","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/tags/algorithm/"}]},{"title":"Master theorem","slug":"016-Master-theorem","date":"2017-02-04T07:34:57.000Z","updated":"2017-02-05T06:11:30.000Z","comments":true,"path":"2017/02/04/016-Master-theorem/","link":"","permalink":"https://huklee.github.io/2017/02/04/016-Master-theorem/","excerpt":"","text":"Master theoremrecursive algorithm을 구현할 때, 점화식으로부터 시간 복잡도를 구할 때 사용되는 theorem이다. 기본적으로 점화식이 다음과 같이 나올 경우에 대해서, 다음 세 가지 usecase 로 나누어서 해당 algorithm의 time complexity를 측정하는 것이 가능하다. Example유명하게 알려져 있는 recursive algorithm에 Master theorem을 대입하면 다음과 같다. further questions 각각 다음과 같은 식으로 점화식이 분리가 되어서 나올 때는 어떻게 식을 적용해야 하는 지는 좀 헷갈린다. T(n) = T(0.4n) + T(0.6n) + O(n) T(n) = T(0.4n) + T(0.2n) + O(n^2) Userful linksMaster theorem, Wikipedia","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/tags/algorithm/"}]},{"title":"Tips on tech interviews by Gayle Mac","slug":"030.Summay_Hackerrank_Gayle_Mc","date":"2017-02-01T14:08:35.000Z","updated":"2017-02-01T14:14:50.000Z","comments":true,"path":"2017/02/01/030.Summay_Hackerrank_Gayle_Mc/","link":"","permalink":"https://huklee.github.io/2017/02/01/030.Summay_Hackerrank_Gayle_Mc/","excerpt":"","text":"Tips on tech interviews by Gayle Mac1. how companies evaluate tech interviews you gotta focus on communications Talk a lot loud to express thought process At least, try to summarize what you try to do little mumbles are better than staying silent 2. how to approach behavioral questions short intro quick shows of success key strories (let the interview ask for details) hobbies (tech / non-tech) prepare to dicuss at least 2-3 projects in detail techinial role soft skills about the bad stuff mistakes failures 3. 7 steps to solve algorithm problems listen example brute force optimize walk through your algorithm code on a writeboard or on a paper coding style matters consistnet braces descriptive variables modulize test analyse use test cases 4. 3 algorithm strategies BUD Bottlenecks what details make the algorithm slow? how can we improve that? Unneccessary work is there any unneccessary work to make the algo faster? Duplicated work same with the above Space / Time trade-offs Hashtable : good example of space/time trade-offs DIY Use your brain to find a shortcut algorithm Try a large &amp; generic example Useful LinksHow companies evaluate tech interviews - Gayle Mc How to approach behavioral questions - Gayle Mc 7 Step to solve algorithm problems - Gayle Mc 3 Algorithm Strategies - Gayle Mc","categories":[{"name":"Tips","slug":"Tips","permalink":"https://huklee.github.io/categories/Tips/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"https://huklee.github.io/tags/Tips/"}]},{"title":"Tips using linux","slug":"029.Linux+Tips","date":"2017-02-01T13:33:35.000Z","updated":"2017-02-11T05:19:51.000Z","comments":true,"path":"2017/02/01/029.Linux+Tips/","link":"","permalink":"https://huklee.github.io/2017/02/01/029.Linux+Tips/","excerpt":"","text":"Tips using linuxUpload &amp; download files using SCP local sever -&gt; remote server 1scp abc@111.222.333.444:/home/abc/* /home/me/ remote sever -&gt; local server 1scp /home/me/ abc@111.222.333.444:/home/abc/* in case of using other port as SSH 1scp -P 2222 abc@1.2.3.4:/home/abc/* /home/me/ List all files including folders 1find . excluding folders 1find . -type f 다른 계정으로 bash 명령 실행하기 계정 이름, host 주소만 필요할 경우 1ssh [id]@[host] [command] password도 필요한 경우 1sshpass -p [password] ssh [id]@[host] [command] bash error handling error 발생시 스크립트 종료하기 1[bash_command] || [error_handling_function] example 12345678function error_exit&#123; echo \"$1\" 1&gt;&amp;2 exit 1&#125;# [bash_command] || error_exit [error_message]cd $some_directory || error_exit \"Cannot change directory! Aborting.\" Using bash script on python simple way without a return value 12import os, sysos.system(\"ls -al\") the way with a return value (printed value) 123456import subprocessdef bashcmd (cmd, isPrint=True): result = subprocess.check_output(cmd, shell=True) print result.decode(\"utf-8\")bashcmd ('ls -al') in case of python &lt; 2.7 import subprocess if \"check_output\" not in dir( subprocess ): # duck punch it in! def f(*popenargs, **kwargs): if 'stdout' in kwargs: raise ValueError('stdout argument not allowed, it will be overridden.') process = subprocess.Popen(stdout=subprocess.PIPE, *popenargs, **kwargs) output, unused_err = process.communicate() retcode = process.poll() if retcode: cmd = kwargs.get(\"args\") if cmd is None: cmd = popenargs[0] raise subprocess.CalledProcessError(retcode, cmd) return output subprocess.check_output = f def bashcmd (cmd, isPrint=True): result = subprocess.check_output(cmd, shell=True) print result.decode(\"utf-8\") bashcmd ('ls -al') Useful Linksfile upload &amp; download between Linux machines using scp python 사용하여 bash shell 사용 how to use subprocess.check_output() in python 2.6 다른 계정으로 명령 실행하기 using ssh with password error handling with bash","categories":[{"name":"Tips","slug":"Tips","permalink":"https://huklee.github.io/categories/Tips/"},{"name":"Linux","slug":"Tips/Linux","permalink":"https://huklee.github.io/categories/Tips/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://huklee.github.io/tags/Linux/"}]},{"title":"Install R & Rstudio in CLI on Mac","slug":"028.Install-R-Rstudio-in-CLI","date":"2017-01-31T14:33:35.000Z","updated":"2017-01-31T14:49:01.000Z","comments":true,"path":"2017/01/31/028.Install-R-Rstudio-in-CLI/","link":"","permalink":"https://huklee.github.io/2017/01/31/028.Install-R-Rstudio-in-CLI/","excerpt":"","text":"Install R &amp; Rstudio in CLI on MacInstall homebrewHomebrew is awesome, since you can just install things wtih your terminal, like yum, apt-get in Ubuntu. First, turn on your terminal. If you didn’t install homebrew yet, just copy &amp; paste the following script. 1ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" or you already installed homebrew, just update it. 1brew update &amp;&amp; brew upgrade Install R &amp; RstudioYou gotta extend the respositories by installing Cask. Just don’t be cared, follow the steps of each line. 12345678910brew tap caskroom/caskbrew install brew-caskbrew install Caskroom/cask/xquartzbrew cask install javabrew tap homebrew/sciencebrew install Rbrew install Caskroom/cask/rstudio Then, you can get this. note While you got into several steps, it would bootstrap. It could take more than an hour sometimes. Don’t be panic, and take a cup of coffee reading some posts in Facebook or some. Useful linksR for Mac Rstudio for Mac How to install R &amp; Rstudio Shiny in Rstudio","categories":[{"name":"Data Science","slug":"Data-Science","permalink":"https://huklee.github.io/categories/Data-Science/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://huklee.github.io/tags/Mac/"},{"name":"R","slug":"R","permalink":"https://huklee.github.io/tags/R/"},{"name":"brew","slug":"brew","permalink":"https://huklee.github.io/tags/brew/"}]},{"title":"Cracking the coding interview summary","slug":"027.Cracking the coding interview summary","date":"2017-01-29T17:22:38.000Z","updated":"2017-02-04T07:37:09.000Z","comments":true,"path":"2017/01/30/027.Cracking the coding interview summary/","link":"","permalink":"https://huklee.github.io/2017/01/30/027.Cracking the coding interview summary/","excerpt":"","text":"Important Data Structure array &amp; string linked Lists stack &amp; queue tree &amp; graph Important algorithms &amp; concepts bit manipulations probabilities OOP Recursive &amp; Dynamic Programming Sort &amp; Search Scalability &amp; memory issues Testing Knowledge C++ database thread &amp; lock Data Structure termsTree Tree = acyclic graph Binary tree = tree that consists of 2-children nodes Binary Search Tree = binary tree with the relationship between all parent(p) and left child(l), right child(r), such that l.val &lt;= p.val &lt; r.val Depth Min : logn // Max : n Search Best : O(logn) // Wost : O(n) Traverse pre-order : parent -&gt; left subtree -&gt; right subtree in-order : left subtree -&gt; parent -&gt; right subtree post-order : left subtree -&gt; right subtree -&gt; parent Balanced BST Red-Black Tree AVL Tree Treap : tree + heap, randomized binary search tree implementation node implementation Array vs Dynamic memory Useful LinksTree Data structure Binary Tree BST","categories":[{"name":"Tips","slug":"Tips","permalink":"https://huklee.github.io/categories/Tips/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/tags/algorithm/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"https://huklee.github.io/tags/Data-Structure/"}]},{"title":"my vim cheat sheet","slug":"026.my-vim-cheat-sheet","date":"2017-01-29T11:05:32.000Z","updated":"2017-01-29T15:38:58.000Z","comments":true,"path":"2017/01/29/026.my-vim-cheat-sheet/","link":"","permalink":"https://huklee.github.io/2017/01/29/026.my-vim-cheat-sheet/","excerpt":"","text":"Huklee’s Vim cheet sheet1. Using bash shell commands 1:! [bash_cmd] run a shell1:sh 2. Auto-indent all lines 1gg=G for selected lines 12[selected mode]= 3.Useful LinksVim tips working external commands vim cheat sheet","categories":[{"name":"Tips","slug":"Tips","permalink":"https://huklee.github.io/categories/Tips/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://huklee.github.io/tags/vim/"}]},{"title":"Binary search problem","slug":"023.Binary-search-problem","date":"2017-01-27T16:25:57.000Z","updated":"2017-01-27T16:34:18.000Z","comments":true,"path":"2017/01/28/023.Binary-search-problem/","link":"","permalink":"https://huklee.github.io/2017/01/28/023.Binary-search-problem/","excerpt":"","text":"1. Bianry Search for closest number problem Input : ordred list of integers, a given number Ouptut : find the the closest number to the given number solution in python 123456789101112131415# recursion solutiondef solve(arr, num, start=0): # 01. base case : size() &lt;= 3 if len(arr) &lt;= 3: minVal = min([abs(x - num) for x in arr]) for i in range(len(arr)): if minVal == abs(arr[i] - num): return start + i # 02. check the mid value then exclude the wrong side mid = int(len(arr)/2) if arr[mid] &lt; num: return solve(arr[mid + 1:], num, start + mid + 1) else: return solve(arr[:mid + 1], num, start) solution in C++ 12345678910111213141516171819// recursive solutionint solve(vector&lt;int&gt; arr, int num, int start, int end)&#123; // 01. base case : size() &lt;= 3 if (end - start &lt;= 2)&#123; int min_val = abs(num - arr[start]); for (int i=start; i &lt;= end; i++) min_val = min(abs(num - arr[i]), min_val); for (int i=start; i &lt;= end; i++) if min_val == abs(num - arr[i]) return i; &#125; // 02. check the mid value then exclude the wrong side int mid = (end - start)/2; if (arr[mid] &lt; num) return solve(arr, num, mid + 1, end); else return solve(arr, num, start, mid);&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/tags/algorithm/"}]},{"title":"SQL tutorials","slug":"022.SQL-tutorials","date":"2017-01-27T16:14:18.000Z","updated":"2017-01-27T16:25:31.000Z","comments":true,"path":"2017/01/28/022.SQL-tutorials/","link":"","permalink":"https://huklee.github.io/2017/01/28/022.SQL-tutorials/","excerpt":"","text":"SQL : Structured Query Language SQL tutorialsDB를 다루는 데 기본적인 query를 배우기 위해서는 SQL을 알아야 한다. 어느 정도 사용법을 익숙해 지기 위해서는 다음 튜토리얼을 따라가면 금방 익힐 수 있다. SQL Tutorials 사이트에서는 간단한 SQL Testbed를 제공하는데, 훌륭한 예제 database가 들어가 있어서, 왠만한 기본 기능을 익히고 테스트 하는 데 괜찮다. crate table &amp; insert into를 사용하면 데이터를 넣는 것도 가능하지 때문에, 이것저것 스스로 예제를 만들어서 간단히 테스트하는 것도 가능하다. SQL try testbed Advanced다음은 개인적으로 사용법이 좀 헷갈리는 것들을 정리해 놓은 것 Group By12345678910SELECT orderid, SUM(total) as total_price, AVG(total)/SUM(quantity) as average_price_of_items, SUM(quantity) as ItemsFROM( SELECT *, quantity*price as total FROM [orderdetails] as o LEFT JOIN [products] as p WHERE o.productID = p.productID)GROUP BY orderid; =&gt; orderid 별로 total_price, average_price_of item, num_items를 구하는 SQL Query Useful Linksmysql installation on Mac Using database indexes SQL cheet Sheet","categories":[{"name":"database","slug":"database","permalink":"https://huklee.github.io/categories/database/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://huklee.github.io/tags/SQL/"},{"name":"database","slug":"database","permalink":"https://huklee.github.io/tags/database/"}]},{"title":"SQL all kinds of join queries","slug":"021.SQL-all-kinds-of-join-queries","date":"2017-01-27T16:01:45.000Z","updated":"2017-01-27T16:13:45.000Z","comments":true,"path":"2017/01/28/021.SQL-all-kinds-of-join-queries/","link":"","permalink":"https://huklee.github.io/2017/01/28/021.SQL-all-kinds-of-join-queries/","excerpt":"","text":"All kinds of SQL QueriesType 1: INNER JOIN - only where both tables match1.) INNER JOIN aka JOIN 123SELECT *FROM table1 as a (INNER) JOIN table2 as bON a.id = b.id; Type 2: OUTER JOINS where either one or both tables match1.) LEFT OUTER JOIN aka LEFT JOIN 123SELECT *FROM table1 as a LEFT (OUTER) JOIN table2 as bON a.id = b.id; 2.) RIGHT OUTER JOIN aka RIGHT JOIN 123SELECT *FROM table1 as a RIGHT (OUTER) JOIN table2 as bON a.id = b.id; 3.) FULL OUTER JOIN aka FULL JOIN (supported depending on what database program) 123SELECT *FROM table1 as a FULL OUTER JOIN table2 as bON a.id = b.id; Type 3: CROSS JOIN - Cartesian product(all possible combos of each table) (supported depending on what database program) 12SELECT *FROM table1 as a CROSS JOIN table2 as b; Useful Linksstackoverflow on SQL Cross Join &amp; Self Join","categories":[{"name":"database","slug":"database","permalink":"https://huklee.github.io/categories/database/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://huklee.github.io/tags/SQL/"},{"name":"database","slug":"database","permalink":"https://huklee.github.io/tags/database/"}]},{"title":"counting millisec time in bash on Mac","slug":"020.counting-millisec-time-in-bash-on-Mac","date":"2017-01-22T06:02:25.000Z","updated":"2017-02-11T05:20:38.000Z","comments":true,"path":"2017/01/22/020.counting-millisec-time-in-bash-on-Mac/","link":"","permalink":"https://huklee.github.io/2017/01/22/020.counting-millisec-time-in-bash-on-Mac/","excerpt":"","text":"Counting time with accuracy of milliseconds in bash on MacCounting time with accuracy of milliseconds in normal bashbash에서 프로그램을 실행시켜서 실행시간을 재는 간단한 bash script는 아래와 같다. milliseconds 단위로 실행시간을 측정할 수 있다. 123456789101112131415161718# countTime.sh#!/bin/bashargc=$#if [ $argc -eq 0 ]; then echo \"usage ./countTime.sh program_to_run\" exitfi# check the beginning timebeginTime=$(date +%s%N)# runt the first parameterseval $1endTime=$(date +%s%N)elapsed=`echo \"($endTime - $beginTime) / 1000000\" | bc`elapsedSec=`echo \"scale=6;$elapsed / 1000\" | bc | awk '&#123;printf \"%.6f\", $1&#125;'`echo TOTAL: $elapsedSec sec on BSD, the default linux type of Mac문제는 BSD linux 에서는 기본적으로 date가 milliseconds기록을 기본적으로 지원하지 않는다. 그래서 기본적으로 아래와 같은 결과가 나온다. 12$ date +%s.%N1485066528.N 따라서 coreutils라는 패키지를 깔아서 gdate로 사용해야 한다. 설치 방법은 아래를 참조하자. brew는 기본적으로 설치되었다고 가정한다. 1brew install coreutils 다음은 bash의 alias로 date를 gdate로 바꿔준다. 1vim ~/.bash_profile 아래 내용을 추가하자. alias date=’/usr/local/bin/gdate’ 그러면 이제 date +%s.N을 했을 떄 제대로 나오는 것을 확인할 수 있다! 위에서 만든 스크립트도 제대로 사용이 가능하다. 12$ date +%s.%N1485066528.720920000 Useful Links경과시간 출력하기 counting time on Mac bash","categories":[{"name":"Tips","slug":"Tips","permalink":"https://huklee.github.io/categories/Tips/"},{"name":"Mac","slug":"Tips/Mac","permalink":"https://huklee.github.io/categories/Tips/Mac/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://huklee.github.io/tags/Mac/"},{"name":"bash","slug":"bash","permalink":"https://huklee.github.io/tags/bash/"},{"name":"Linux","slug":"Linux","permalink":"https://huklee.github.io/tags/Linux/"}]},{"title":"markdown cheat sheet","slug":"019.markdown-cheat-sheet","date":"2017-01-21T13:39:46.000Z","updated":"2017-01-21T14:02:36.000Z","comments":true,"path":"2017/01/21/019.markdown-cheat-sheet/","link":"","permalink":"https://huklee.github.io/2017/01/21/019.markdown-cheat-sheet/","excerpt":"","text":"1. Headers123456# H1## H2### H3#### H4##### H5###### H6 H1H2H3H4H5H62. Blockquotes123456&gt; Blockquotes are very handy in email to emulate reply text.&gt; This line is part of the same quote.Quote break.&gt; This is a very long line that will still be quoted properly when it wraps. Oh boy let&apos;s keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can *put* **Markdown** into a blockquote. Blockquotes are very handy in email to emulate reply text.This line is part of the same quote. Quote break. This is a very long line that will still be quoted properly when it wraps. Oh boy let’s keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can put Markdown into a blockquote. 3. Tables123456789101112| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 |There must be at least 3 dashes separating each header cell. The outer pipes (|) are optional, and you don&apos;t need to make the raw Markdown line up prettily. You can also use inline Markdown.Markdown | Less | Pretty--- | --- | ---*Still* | `renders` | **nicely**1 | 2 | 3 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 There must be at least 3 dashes separating each header cell. The outer pipes (|) are optional, and you don’t need to make the raw Markdown line up prettily. You can also use inline Markdown. Markdown Less Pretty Still renders nicely 1 2 3 Useful LinksGithub markdown cheat sheet","categories":[],"tags":[]},{"title":"algospot_traversal","slug":"018.algospot-traversal","date":"2017-01-21T10:27:20.000Z","updated":"2017-01-29T15:33:47.000Z","comments":true,"path":"2017/01/21/018.algospot-traversal/","link":"","permalink":"https://huklee.github.io/2017/01/21/018.algospot-traversal/","excerpt":"","text":"Algospot Traversalarray의 start, end 포인트만을 사용한 풀이12345678910111213141516171819202122232425262728293031323334353637383940414243// TRAVERSALint preTree[N_MAX];int inTree[N_MAX];int postTree[N_MAX];void guessPostTree(int preS, int preE, int inS, int inE, int postS, int postE)&#123; if (postS &gt; postE) return; // Initial Case int root; for (root = inS; root &lt;= inE; root++)&#123; if (preTree[preS] == inTree[root]) break; &#125; postTree[postE] = inTree[root]; // Recursive int leftLen = root - inS; guessPostTree(preS + 1, preS + leftLen, inS, root - 1, postS, postS + leftLen - 1); // Left guessPostTree(preS + leftLen + 1, preE, root + 1, inE, postS + leftLen, postE - 1); // Right cout &lt;&lt; inTree[root] &lt;&lt; \" \";&#125;int main()&#123; int T, N, i, j; cin &gt;&gt; T; for (int tc = 0; tc &lt; T; tc++)&#123; cin &gt;&gt; N; for (i = 0; i &lt; N; i++) cin &gt;&gt; preTree[i]; for (i = 0; i &lt; N; i++) cin &gt;&gt; inTree[i]; vector&lt;int&gt; v1(preTree, preTree + N); vector&lt;int&gt; v2(inTree, inTree + N); guessPostTree(0, N - 1, 0, N - 1, 0, N - 1); cout &lt;&lt; endl; &#125; return 0;&#125; slice()를 이용한 깔끔한 vector를 주고 받는 풀이12345678910111213141516171819202122232425262728293031323334353637vector&lt;int&gt; slice(const vector&lt;int&gt;&amp; v, int a, int b)&#123; return vector&lt;int&gt;(v.begin() + a, v.begin() + b);&#125;void guessPostTree(const vector&lt;int&gt;&amp; preorder, const vector&lt;int&gt;&amp; inorder)&#123; // 00. exit condition if (preorder.empty()) return; // 01. find the root and the pos of the root int N = preorder.size(); int root = preorder[0]; int leftLen = find(inorder.begin(), inorder.end(), root) - inorder.begin(); // 02. print the left &amp; right trees, then the root guessPostTree(slice(preorder, 1, leftLen + 1), slice(inorder, 0, leftLen)); // left sub-tree guessPostTree(slice(preorder, leftLen + 1, N), slice(inorder, leftLen + 1, N)); // right sub-tree cout &lt;&lt; root &lt;&lt; \" \";&#125;int main()&#123; int T, N, i, j; cin &gt;&gt; T; for (int tc = 0; tc &lt; T; tc++)&#123; cin &gt;&gt; N; for (i = 0; i &lt; N; i++) cin &gt;&gt; preTree[i]; for (i = 0; i &lt; N; i++) cin &gt;&gt; inTree[i]; vector&lt;int&gt; v1(preTree, preTree + N); vector&lt;int&gt; v2(inTree, inTree + N); guessPostTree(v1, v2); cout &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/categories/algorithm/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://huklee.github.io/tags/C/"},{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/tags/algorithm/"},{"name":"Tree","slug":"Tree","permalink":"https://huklee.github.io/tags/Tree/"},{"name":"Algospot","slug":"Algospot","permalink":"https://huklee.github.io/tags/Algospot/"}]},{"title":"intro to design patterns","slug":"017.intro-to-design-patterns","date":"2017-01-20T17:29:58.000Z","updated":"2017-02-26T14:53:14.000Z","comments":true,"path":"2017/01/21/017.intro-to-design-patterns/","link":"","permalink":"https://huklee.github.io/2017/01/21/017.intro-to-design-patterns/","excerpt":"","text":"Design patterns가장 유명한 디자인 패턴으로는 GoF Design pattern이 있다. 하도 유명해서 필수로 알아두면 좋을 패턴들은 다음과 같다. Relational diagram Creational patterns Abstract factory pattern groups object factories that have a common theme. Builder pattern constructs complex objects by separating construction and representation. ex) Car builder Factory method pattern creates objects without specifying the exact class to create. Prototype pattern creates objects by cloning an existing object. Singleton pattern restricts object creation for a class to only one instance. implementation in c++ Structural patterns Adapter allows classes with incompatible interfaces to work together by wrapping its own interface around that of an already existing class. ex) wrapper function / Delegation Bridge decouples an abstraction from its implementation so that the two can vary independently. Composite composes zero-or-more similar objects so that they can be manipulated as one object. Decorator dynamically adds/overrides behavior in an existing method of an object. ex) Windowing system Facade provides a simplified interface to a large body of code. ex) API Flyweight reduces the cost of creating and manipulating a large number of similar objects. Proxy provides a placeholder for another object to control access, reduce cost, and reduce complexity. Behavioral patterns Chain of responsibility delegates commands to a chain of processing objects. Command creates objects which encapsulate actions and parameters. Interpreter implements a specialized language.Iterator accesses the elements of an object sequentially without exposing its underlying representation. Mediator allows loose coupling between classes by being the only class that has detailed knowledge of their methods. Memento provides the ability to restore an object to its previous state (undo). Observer is a publish/subscribe pattern which allows a number of observer objects to see an event. ex) MVC : java.swing / [c#]winform State allows an object to alter its behavior when its internal state changes. Strategy allows one of a family of algorithms to be selected on-the-fly at runtime. ex) java) 동물 클래스 구성하기 / c#) 스타크래프트 디자인 Template method defines the skeleton of an algorithm as an abstract class, allowing its subclasses to provide concrete behavior. Visitor separates an algorithm from an object structure by moving the hierarchy of methods into one object. etc Factory Pattern vs Builder patterns굉장히 비슷한 기능적인 설계 구조를 가지고 있는 두 가지 패턴이다. 둘 다 정형화된 class를 만드는 interface를 abstraction 시키는 데 매우 편리하게 사용되는 패턴이다. 다른 점이 있다면 만드는 product의 개수가 일반적으로 Factory는 n개, Builder는 1개로 한다는 점이다. Factory Pattern의 경우 n개의 method가 products의 각각 다른 리턴타입을 가질 수 있게 설계하는 것이 보통이다. 하지만, Builder의 경우에는 보통 1개의 method, construct() 만이 product를 리턴할 수 있게 설계하는 것이 일반적인 차이이다. Builder focuses on constructing a complex object step by step. Abstract Factory emphasizes a family of product objects (either simple or complex). Builder returns the product as a final step, but as far as the Abstract Factory is concerned, the product gets returned immediately. about htis in SOF MVC design patterns MVC : Model, View, Controller의 앞글자를 딴 것을 의미며, 어플리케이션의 역할을 세 가지로 구분한 개발 방법론이다. 핵심은 사용자가 직접 Model을 만지지 않도록 하는 구조라고 볼 수 있다. 아래처럼 사용자가 Controller를 조작하면, Controller가 Model을 통해서 데이터를 가져오고 그 정보를 바탕으로 View를 통해서 사용자에게 정보를 제공하는 구조이다. 추가로 비슷한 디자인 패턴 구조로는 MVP (Model, View, Presenter), MVVM (Model, View, View Model)가 있다. 두 모델은 View와 Model을 분리해 주는 장점을 가지고 있다. MVVM에서는 View가 보는 Data는 Model의 원래 정보가 아닌 View Model을 통해 간접적으로 얻는 Data이며, event를 통해서 view model의 변화를 Control하는 특징이 있다. GoF 패턴의 Observer 패턴과 연관성이 매우 크다. 객체의 상태변화, event, call-back function 등의 특성이 observer 패턴의 핵심 구성요소이기 때문이다. useful linksMVC, MVP, MVVM 차이점 Design pattern examples from non-program Design patterns Design patterns in source making UML Class diagram &amp; Source code mapping","categories":[{"name":"programming","slug":"programming","permalink":"https://huklee.github.io/categories/programming/"}],"tags":[{"name":"design patterns","slug":"design-patterns","permalink":"https://huklee.github.io/tags/design-patterns/"}]},{"title":"How to use C++ STL well?","slug":"015.How-to-use-C-STL-well","date":"2017-01-19T14:09:34.000Z","updated":"2017-03-03T10:58:42.000Z","comments":true,"path":"2017/01/19/015.How-to-use-C-STL-well/","link":"","permalink":"https://huklee.github.io/2017/01/19/015.How-to-use-C-STL-well/","excerpt":"","text":"Usage examplestd::list std::vector std::unordered_map following should be complied by more than c++11. 1$ g++ -std=c++11 main.cpp the example code is following priority queue Useful linksC++ 공부할 때 읽으면 좋을 책들 STL은 정말 괜찮은 물건인가? C++ 책 추천: 해외/번역서 기준 from SOF Effective STL_pdf C-Tutorial-A-Beginners-Guide-to-stdvector C++ std::vector reference C++ std::unordered_map C++ std::priority_queue","categories":[{"name":"Programming_Language","slug":"Programming-Language","permalink":"https://huklee.github.io/categories/Programming-Language/"},{"name":"C++","slug":"Programming-Language/C","permalink":"https://huklee.github.io/categories/Programming-Language/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://huklee.github.io/tags/C/"},{"name":"stl","slug":"stl","permalink":"https://huklee.github.io/tags/stl/"}]},{"title":"Things interesting","slug":"025.Things-interesting","date":"2017-01-18T00:08:31.000Z","updated":"2017-01-29T15:38:47.000Z","comments":true,"path":"2017/01/18/025.Things-interesting/","link":"","permalink":"https://huklee.github.io/2017/01/18/025.Things-interesting/","excerpt":"","text":"EducationMOOC Udacity / Intro do Big data Free / 2 Months Udacity / Intro to Hadoop and Mapreduce Free / 1 Month Coursera / Data Science specialization $49.00 USDper month / 3~6 months Coursera / Functional Programming in Scala specialization $395 USD / 4~5 months","categories":[{"name":"etc","slug":"etc","permalink":"https://huklee.github.io/categories/etc/"}],"tags":[{"name":"etc","slug":"etc","permalink":"https://huklee.github.io/tags/etc/"},{"name":"education","slug":"education","permalink":"https://huklee.github.io/tags/education/"}]},{"title":"manual for Node.js","slug":"024.manual-for-Node-js","date":"2017-01-17T14:20:40.000Z","updated":"2017-01-29T11:20:25.000Z","comments":true,"path":"2017/01/17/024.manual-for-Node-js/","link":"","permalink":"https://huklee.github.io/2017/01/17/024.manual-for-Node-js/","excerpt":"","text":"node.jsDesign Goal Function은 직접 플랫폼 I/O에 접속하지 않습니다. Disk, network, 프로세스를 통해 데이터를 받기 위해서는 대부분 콜백(callback)을 사용합니다. TCP, DNS, HTTP같은 프로토콜을 지원합니다. HTTP feature를 지원합니다.(Chunk된 requst/response, Keep-alive, Comet을 위한 리퀘스트 홀딩) Internal Design features Google의 V8 사용 Marc Lehmann이 만든 이벤트루프 라이브러리 libev 사용 linksnode.js 언어 디자인 측면에서의 분석 node.js 소개 및 내부구조에 관한 이론 node.js at jsconf 2009 node.js 튜토리얼","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://huklee.github.io/categories/Tutorial/"},{"name":"node.js","slug":"Tutorial/node-js","permalink":"https://huklee.github.io/categories/Tutorial/node-js/"}],"tags":[{"name":"usage","slug":"usage","permalink":"https://huklee.github.io/tags/usage/"},{"name":"javascript","slug":"javascript","permalink":"https://huklee.github.io/tags/javascript/"},{"name":"node.js","slug":"node-js","permalink":"https://huklee.github.io/tags/node-js/"}]},{"title":"Jupyter_usage","slug":"014.Jupyter-usage","date":"2017-01-17T14:19:38.000Z","updated":"2017-01-18T00:01:57.000Z","comments":true,"path":"2017/01/17/014.Jupyter-usage/","link":"","permalink":"https://huklee.github.io/2017/01/17/014.Jupyter-usage/","excerpt":"","text":"Jupyter UsageMarkdownMastering Markdown How to make tables Markdown Tutorial Basic writing and formatting syntax of Markdown Converting Table Data (excel, csv) into Markdown Table","categories":[{"name":"Programming_Language","slug":"Programming-Language","permalink":"https://huklee.github.io/categories/Programming-Language/"},{"name":"python","slug":"Programming-Language/python","permalink":"https://huklee.github.io/categories/Programming-Language/python/"}],"tags":[{"name":"jupyter","slug":"jupyter","permalink":"https://huklee.github.io/tags/jupyter/"},{"name":"notebook","slug":"notebook","permalink":"https://huklee.github.io/tags/notebook/"},{"name":"usage","slug":"usage","permalink":"https://huklee.github.io/tags/usage/"},{"name":"python","slug":"python","permalink":"https://huklee.github.io/tags/python/"}]},{"title":"how to start a wiki","slug":"013.how-to-start-a-wiki","date":"2017-01-17T14:18:28.000Z","updated":"2017-01-17T14:19:18.000Z","comments":true,"path":"2017/01/17/013.how-to-start-a-wiki/","link":"","permalink":"https://huklee.github.io/2017/01/17/013.how-to-start-a-wiki/","excerpt":"","text":"how to start a wikiPopular Wikis MediaWiki 가장 유명한 위키 프로그램. 위키하우, 위키피디아 등 많은 사이트에 사용된다. 다른 위키 사이트들 중에서 쓰는 사이트도 많다.[3] TikiWiki 두번째로 유명한 위키 프로그램. 많은 사이트에서 사용된다. 플러그인 지원이 좋아서 포럼, 이미지 갤러리, 달력 등의 기능을 쉽게 추가할 수 있다. UserPress 워드프레스용 위키 플러그인. MediaWiki와 다른 위키의 기능을 다 갖추고 있으며, 쓰기도 쉽다. DokuWiki 작지만 인기가 늘어가고 있는 위키 프로그램. 특히 회사들에서 많이 쓰인다. 팀이나 회사에서 협업을 위해 많이 쓰여며, 사용자 권한에 따라 접근할 수 있는 문서가 달라진다. linkshow to start a Mediawiki Mediawiki를 개인위키로 서비스하기 위키사이트 시작하기","categories":[{"name":"etc","slug":"etc","permalink":"https://huklee.github.io/categories/etc/"}],"tags":[{"name":"wiki","slug":"wiki","permalink":"https://huklee.github.io/tags/wiki/"}]},{"title":"How_to_install_Jupyter_Notebook_in_Ubuntu","slug":"012.How-to-install-Jupyter-Notebook-in-Ubuntu","date":"2017-01-17T14:16:12.000Z","updated":"2017-01-18T00:01:59.000Z","comments":true,"path":"2017/01/17/012.How-to-install-Jupyter-Notebook-in-Ubuntu/","link":"","permalink":"https://huklee.github.io/2017/01/17/012.How-to-install-Jupyter-Notebook-in-Ubuntu/","excerpt":"","text":"Ubuntu에 jupyter notebook 설치 및 웹프라우저로 원격접속 설정 설치환경 : linux (Ubuntu 14.04.1) 주의할 점jupyter가 개인용으로 만들어서 져서, 여러 명이 쓰기에는 부적절하긴 하다. 같은 파일을 동시에 고치거나 하면 서버가 다운될 확률이 다분하니, 굳이 여러 명이 써야할 경우에는 되도록 각자 작업할 수 있도록 하자. 여러 명이 안정적으로 사용하는 환경을 구축하고 싶다면 jupyterHub가 더 적절하니 이를 참고하자. 설치 순서 https://www.continuum.io/downloads#linux 에서 최선 Anaconda download winSCP를 사용하여 설치파일 전송 (/tmp/Anaconda3-4.2.0-Linux-x86_64.sh) putty로 접속하여 해당 파일 실행하여 설치 (bash /tmp/Anaconda3-4.2.0-Linux-x86_64.sh) yes 혹은 엔터로 쭉쭉 진행 설치 후 재부팅 (reboot) jupyter notebook –generate-config 실행 mkdir /usr/jupyter 실행 (jupyter notebook의 root폴더 생성) vim /root/.jupyter/jupyter_notebook_config.py 하여 해당 내용 맨 아랫줄에 추가 123c = get_config()c.NotebookApp.ip = '10.240.35.100' # ip address of the serverc.NotebookApp.port = 8080c.FileContentsManager.root_dir = '/usr/jupyter/' vim /etc/init.d/jupyter 실행, 아래 내용 적고 저장 1jupyter notebook chmod 755 /etc/init.d/jupyter cd /etc/init.d sudo update-rc.d /etc/init.d/jupyter defaults 다시 재부팅 (reboot) 보안 키 설정하기위의 설정대로만 하면 jupyter notebook 접속 시 보안키가 전혀 필요하지 않다. 반면에 비밀번호를 설정해서 보안을 조금 강화하고 싶다면 아래와 같이 설정을 추가하면 된다. hash key 만들기 ipython을 실행하여 아래 명령을 수행하자. 1$ ipython 12from notebook.auth import passwdpasswd() 적당한 password를 두 번 치면 아래와 같이 hashed password를 얻을 수 있다. 123Enter password:Verify password:Out[2]: &apos;sha1:67c9e60bb8b6:9ffede0825894254b2e042ea597d771089e11aed&apos; SSL 사용 설정 SSL을 이용하면 브라우저에서 패스워드가 암호화되서 보내지기 때문에 보안이 훨씬 좋아진다. 이를 위해서 self-signed certificate를 생성 하자. OpenSSL을 이용해서 certificate을 생성할 수 있다. 유효기간은 365일이다. 1openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout mycert.pem -out mycert.pem jupyter_notebook_config.py 에 password 추가 추가할 내용은 아래와 같다. password에는 1.에서 얻은 hashed password를 그대로 넣으면 되며, certiflie에는 2.에서 생성한 .pem 파일을 지정하여 집어넣자. path는 임의대로 넣었으니 자신이 지정한 폴더명을 사용하여 진행하자. 12c.NotebookApp.password = u'sha1:67c9e60bb8b6:9ffede0825894254b2e042ea597d771089e11aed'c.NotebookApp.certfile = u'/absolute/path/to/your/certificate/mycert.pem' 끝. Useful Linkshttps://www.continuum.io/downloads#linux http://jupyter-notebook.readthedocs.io/en/latest/public_server.html http://goodtogreate.tistory.com/entry/IPython-Notebook-%EC%84%A4%EC%B9%98%EB%B0%A9%EB%B2%95 http://www.whatwant.com/497 Jupyterhub를 이용하여 Jupyter Notebook 실습 환경 구축하기","categories":[],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://huklee.github.io/tags/Ubuntu/"},{"name":"jupyter","slug":"jupyter","permalink":"https://huklee.github.io/tags/jupyter/"},{"name":"notebook","slug":"notebook","permalink":"https://huklee.github.io/tags/notebook/"},{"name":"python","slug":"python","permalink":"https://huklee.github.io/tags/python/"}]},{"title":"how to gdb on mac","slug":"011.how-to-gdb-on-mac","date":"2017-01-13T15:11:05.000Z","updated":"2017-01-18T00:02:00.000Z","comments":true,"path":"2017/01/14/011.how-to-gdb-on-mac/","link":"","permalink":"https://huklee.github.io/2017/01/14/011.how-to-gdb-on-mac/","excerpt":"","text":"How to gdb on MacSadly, gdb is not built-in package for Mac. On Mac, the easiest way to install a package working mainly in CLI such as gdb, gcc, g++, and etc, is to use Brew (Homebrew). 1ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" then, use the brew to install the gdb package. 1brew install gdb ➜ algorithms git:(master) ✗ brew install gdbUpdating Homebrew…==&gt; Downloading https://homebrew.bintray.com/bottles/gdb-7.12_1.el_capitan.bottle.tar.gz ######################################################################## 100.0%==&gt; Pouring gdb-7.12_1.el_capitan.bottle.tar.gz==&gt; Caveatsgdb requires special privileges to access Mach ports.You will need to codesign the binary. For instructions, see: https://sourceware.org/gdb/wiki/BuildingOnDarwin On 10.12 (Sierra) or later with SIP, you need to run this: echo “set startup-with-shell off” &gt;&gt; ~/.gdbinit==&gt; Summary🍺 /usr/local/Cellar/gdb/7.12_1: 49 files, 6.8M here goes the result! 1$ sudo gdb $ gdb GNU gdb (GDB) 7.12 Copyright (C) 2016 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &gt;http://gnu.org/licenses/gpl.html This is free software: you are free to change andredistribute &gt; it. There is NO WARRANTY, to the extent permitted by law. Type &gt; “show copying” and “show warranty” for details. This GDB was configured as “x86_64-apple-darwin15.6.0”. Type “show configuration” for configuration details. For bug reporting instructions, please see: http://www.gnu.org/software/gdb/bugs/. Find the GDB manual and other documentation resources online at: http://www.gnu.org/software/gdb/documentation/. For help, type “help”. Type “apropos word” to search for commands related to “word”. (gdb) So simple! Just remember that you should run gdb as the super user with “sudo” on mac.","categories":[{"name":"Tips","slug":"Tips","permalink":"https://huklee.github.io/categories/Tips/"},{"name":"Mac","slug":"Tips/Mac","permalink":"https://huklee.github.io/categories/Tips/Mac/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://huklee.github.io/tags/C/"},{"name":"linux","slug":"linux","permalink":"https://huklee.github.io/tags/linux/"},{"name":"gdb","slug":"gdb","permalink":"https://huklee.github.io/tags/gdb/"},{"name":"Mac","slug":"Mac","permalink":"https://huklee.github.io/tags/Mac/"}]},{"title":"gcc, g++, clang and LLVM","slug":"010.gcc-g-clang-and-LLVM","date":"2017-01-06T14:32:43.000Z","updated":"2017-01-18T00:02:01.000Z","comments":true,"path":"2017/01/06/010.gcc-g-clang-and-LLVM/","link":"","permalink":"https://huklee.github.io/2017/01/06/010.gcc-g-clang-and-LLVM/","excerpt":"","text":"How does g++ work with c++11 codes?Let’s say that we run a simple program which consists of following C++ codes.12345678910111213// test_noc++11.cpp#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int arr[] = &#123;1,2,3&#125;; vector&lt;int&gt; vi(arr, arr + sizeof(arr) / sizeof(arr[0])); for (vector&lt;int&gt;::iterator it=vi.begin(); it != vi.end(); it++)&#123; cout &lt;&lt; *it &lt;&lt; endl; &#125; return 0;&#125; when you build this cpp file, it works well with g++. 12345$ g++ test_noc++11.cpp$ ./a.out123 My question starts from here. What about c++11 codes? Does it work with my complier without any problem? So let me go for it. 12345678910111213// test_c++11.cpp#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int arr[] = &#123;1,2,3&#125;; vector&lt;int&gt; vi(arr, arr + sizeof(arr) / sizeof(arr[0])); for (const int&amp; data : vi)&#123; cout &lt;&lt; data &lt;&lt; endl; &#125; return 0;&#125; This code is using the “Range-based for loop” enhancement in C++11. When I tried to compile this, we can see the warning like following. 123456789$ g++ test.cpptest.cpp:9:23: warning: range-based for loop is a C++11 extension [-Wc++11-extensions] for (const int&amp; data : vi)&#123; ^1 warning generated.$ ./a.out123 It works anyway, what about the version of gcc then? 123456$ g++ --versionConfigured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/usr/include/c++/4.2.1Apple LLVM version 8.0.0 (clang-800.0.38)Target: x86_64-apple-darwin15.6.0Thread model: posixInstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin version Release Date GCC 4.2.2 October 7, 2007 GCC 4.2.1 July 18, 2007 GCC 4.2.0 May 13, 2007 the version of gcc is indeed 4.2.1, which doesn’t support C++11 since it’s developed in 2007. What are clang and LLVM?So what makes my code work? What are clang and LLVM? Let’s go a little deeper. Clang /ˈklæŋ/[4] is a compiler front end for the programming languages C, C++, Objective-C, Objective-C++, OpenMP,[5] OpenCL, and CUDA. It uses LLVM as its back end and has been part of the LLVM release cycle since LLVM 2.6. from Wikipedia The LLVM compiler infrastructure project (formerly Low Level Virtual Machine) is a “collection of modular and reusable compiler and toolchain technologies” used to develop compiler front ends and back ends.LLVM is written in C++ and is designed for compile-time, link-time, run-time, and “idle-time” optimization of programs written in arbitrary programming languages. Originally implemented for C and C++, the language-agnostic design of LLVM has since spawned a wide variety of front ends: languages with compilers that use LLVM include ActionScript, Ada, C#, Common Lisp, Crystal, D, Delphi, Fortran, OpenGL Shading Language, Halide, Haskell, Java bytecode, Julia, Lua, Objective-C, Pony, Python, R, Ruby, Rust, CUDA, Scala, and Swift. from Wikipedia All right. I just figured out when I run the g++, llvm-gcc is indeed running, which is the gcc frontend, and then the llvm backend. On the other side, clang++ is running clang, which is the clang frontend and then the llvm backend. Following So, my g++ is actually using clang-LLVM 8.0, which supports c++11, even c++14. DONE. Further questions what are front-end compiler and back-end complier? I should’ve taken the complier coursework during my B.S :( who made the clang &amp; LLVM? are they open-source projects? LinksC++11 WikipediaC++11 Tutorial VideoAdded featured in C++11 Slidegcc release noteclang project homepageclang Wikipedia[LLVM Wikipedia] (https://en.wikipedia.org/wiki/LLVM)g++, clang++ on mac","categories":[{"name":"Programming_Language","slug":"Programming-Language","permalink":"https://huklee.github.io/categories/Programming-Language/"},{"name":"C++","slug":"Programming-Language/C","permalink":"https://huklee.github.io/categories/Programming-Language/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://huklee.github.io/tags/C/"},{"name":"gcc","slug":"gcc","permalink":"https://huklee.github.io/tags/gcc/"},{"name":"g++","slug":"g","permalink":"https://huklee.github.io/tags/g/"},{"name":"clang","slug":"clang","permalink":"https://huklee.github.io/tags/clang/"},{"name":"LLVM","slug":"LLVM","permalink":"https://huklee.github.io/tags/LLVM/"},{"name":"compiler","slug":"compiler","permalink":"https://huklee.github.io/tags/compiler/"}]},{"title":"leetcode_two-sum","slug":"009.leetcode-two-sum","date":"2017-01-03T13:53:01.000Z","updated":"2017-01-21T10:31:50.000Z","comments":true,"path":"2017/01/03/009.leetcode-two-sum/","link":"","permalink":"https://huklee.github.io/2017/01/03/009.leetcode-two-sum/","excerpt":"","text":"leetcode problem solvinghttps://leetcode.com/problems/two-sum/ Brute-force solution : O(n^2)1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; // 1. O(n^2) solution // Brute-force : pick the two number; vector&lt;int&gt; answer = vector&lt;int&gt;(); for (int i=0; i &lt; nums.size(); i++)&#123; int pivot = nums[i]; for (int j=i + 1; j &lt; nums.size(); j++)&#123; int sum = pivot + nums[j]; if(sum == target)&#123; answer.push_back(i); answer.push_back(j); return answer; &#125; &#125; &#125; return answer; &#125;&#125; Hash table using solution : O(n)The key idea is the complement of an answer number must exist (an answer number + the complement number = target). So we just should minimize the time to find the complement number, which I found a hash table is the one. Search the complement number in the existing hash table, and if not found, add the number to the hash table.DONE 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; // 2. O(n) solution // using hash table unordered_map&lt;int, int&gt; hash_table; vector&lt;int&gt; answer = vector&lt;int&gt;(); for (int i=0; i &lt; nums.size(); i++)&#123; int complement = target - nums[i]; if (hash_table.find(complement) != hash_table.end())&#123; answer.push_back(hash_table[complement]); answer.push_back(i); return answer; &#125; hash_table[nums[i]] = i; &#125; return answer; &#125;&#125;;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/categories/algorithm/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://huklee.github.io/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://huklee.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://huklee.github.io/tags/algorithm/"},{"name":"array","slug":"array","permalink":"https://huklee.github.io/tags/array/"}]},{"title":"Objective-C Tutorials","slug":"008.Objective-C-Tutorials","date":"2017-01-01T08:27:52.000Z","updated":"2017-01-18T00:02:02.000Z","comments":true,"path":"2017/01/01/008.Objective-C-Tutorials/","link":"","permalink":"https://huklee.github.io/2017/01/01/008.Objective-C-Tutorials/","excerpt":"","text":"Objective-C Tutorial pages기본적인 Objective-C를 학습하는 데 있어서 필요한 튜토리얼들을 대충 정리해 보았다. Objective-C의 기본개념기본적인 Objective C의 문법과 개념에 대해서 다루고 있는 페이지다. Scott Stevenson의 Objective-C 튜토리얼을 번역한 글이다. 전체적으로 C에서 Objective-C가 어떤 부분에서 다르고, 실제 iOS 어플리케이션을 만들 때 어떤 부분들이 필요한지에 대해서 다루었다. 다만, 기초적인 Tutorial이라고 표현하기에 예제가 부족하고, 개념을 주로 설명하는 편이어서 Objective-C의 지식이 전무한 상태에서 따라가기에는 조금 안 좋아 보인다. 어느 정도 Objective-C의 개념을 훑어보기에 좋다. Objective-C 따라하기 강좌기초적인 예제 중심으로 Objective-C 프로그램을 개발하기에 필요한 부분들을 학습할 수 있는 Tutorial이다. 무작정 따라하기에는 쉽고, 빨리 따라할 수 있는 구성으로 되어 있으니, 추천할 만하다. 그림도 이래저래 많이 친절하게 들어가 있어서 따라가기에 좋다. 다만 C를 이미 학습한 사람들에게 있어서 조금 중복되는 부분이 있을 수 있으니, 이는 감안하고 보는 게 좋을 듯 하다.","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://huklee.github.io/categories/Tutorial/"},{"name":"Objective-C","slug":"Tutorial/Objective-C","permalink":"https://huklee.github.io/categories/Tutorial/Objective-C/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://huklee.github.io/tags/Mac/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://huklee.github.io/tags/Objective-C/"},{"name":"Cocoa","slug":"Cocoa","permalink":"https://huklee.github.io/tags/Cocoa/"},{"name":"iOS","slug":"iOS","permalink":"https://huklee.github.io/tags/iOS/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://huklee.github.io/tags/Tutorial/"}]},{"title":"About me (한글)","slug":"007.About-me-ko","date":"2017-01-01T07:08:45.000Z","updated":"2017-02-11T05:18:23.000Z","comments":true,"path":"2017/01/01/007.About-me-ko/","link":"","permalink":"https://huklee.github.io/2017/01/01/007.About-me-ko/","excerpt":"","text":"EnglishRésumé huklee’s blog에 방문해주셨음에 감사드립니다. huklee는 Software Engineer이고, 다음 주제들에 대해서 관심이 많습니다. Big data platform technology such as, Hadoop echo system Spark Machine learning IoT (Internet of Things) technology such as, Connectivity IoT platorm : raspberry pi, arduino Makers : to transform ideas into things 3D Printer makers movement prototyping 저의 블로그의 대부분의 포스트들은 위에 해당하는 내용들에 대해서 공유할 만한 내용들을 다루고 있습니다. 개인적으로 제가 관심 있고, 좋아하는 것들은 아래와 같아요 :) 수영 철인3종경기 서킷트레이닝 클래식 기타 피아노 재즈","categories":[{"name":"About","slug":"About","permalink":"https://huklee.github.io/categories/About/"}],"tags":[{"name":"About","slug":"About","permalink":"https://huklee.github.io/tags/About/"}]},{"title":"About me (English)","slug":"006.About-me","date":"2017-01-01T06:56:35.000Z","updated":"2017-02-16T07:11:09.000Z","comments":true,"path":"2017/01/01/006.About-me/","link":"","permalink":"https://huklee.github.io/2017/01/01/006.About-me/","excerpt":"","text":"KoreanRésumé I am a software engineer and lifelong learner. I’m interested of Big data platform technology such as, Hadoop echo system Spark Machine learning IoT (Internet of Things) technology such as, Connectivity IoT platorm : raspberry pi, arduino Makers : to transform ideas into things 3D Printer makers movement prototyping Most of what I share on this site will align with these interests. I personally love what inspires me such as, swimming triathlon circuit training classical guitar piano jazz","categories":[{"name":"About","slug":"About","permalink":"https://huklee.github.io/categories/About/"}],"tags":[{"name":"About","slug":"About","permalink":"https://huklee.github.io/tags/About/"}]},{"title":"How to multi-boot Ubuntu & Windows","slug":"005.How-to-multi-boot-Ubuntu-Windows","date":"2017-01-01T05:48:00.000Z","updated":"2017-01-18T00:01:57.000Z","comments":true,"path":"2017/01/01/005.How-to-multi-boot-Ubuntu-Windows/","link":"","permalink":"https://huklee.github.io/2017/01/01/005.How-to-multi-boot-Ubuntu-Windows/","excerpt":"","text":"Ubuntu / Windows를 멀티부팅하는 방법우분투와 윈도우를 멀티부팅하는 법은 일단 파티션을 나누어 둔 두 공간 HDD 혹은 SSD를 준비하여 각각에 설치하면 된다. 순서는 Windows -&gt; Ubuntu 순으로 설치를 하자Ubuntu 같은 경우는 나중에 깔아도 Windows를 고려한 부트로더가 동작하기 때문에 유라하다. 반면에 반대로 하면 Windows는 다른 운영체제를 고려하지 않은 방식으로 부트로더가 돌아가기 때문에 곤란한 상황이 발생할 수 있다. 실제로 예전에 반대로 설치를 했다가 윈도우로 부팅이 안 되어서 운영체제를 싹 다 새로 갈아 엎은 경험이 있다. ㅠ.ㅠ 설치 Note SSD : Windows 10 Pro HDD : Ubuntu 15.04 LTS Useful Links윈도우 10에서 우분투 멀티부팅 설치하기 윈도우와 우분투 멀티부팅 팁 - 이것만은 알아두자","categories":[{"name":"Tips","slug":"Tips","permalink":"https://huklee.github.io/categories/Tips/"},{"name":"linux","slug":"Tips/linux","permalink":"https://huklee.github.io/categories/Tips/linux/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://huklee.github.io/tags/Windows/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://huklee.github.io/tags/Ubuntu/"},{"name":"OS","slug":"OS","permalink":"https://huklee.github.io/tags/OS/"},{"name":"Multi-boot","slug":"Multi-boot","permalink":"https://huklee.github.io/tags/Multi-boot/"}]},{"title":"Effective C++ Summary - Chap 01.","slug":"004.Effective-C-Chap-01","date":"2016-12-31T15:09:38.000Z","updated":"2017-01-17T23:59:03.000Z","comments":true,"path":"2017/01/01/004.Effective-C-Chap-01/","link":"","permalink":"https://huklee.github.io/2017/01/01/004.Effective-C-Chap-01/","excerpt":"","text":"Chap 1. C++에 왔으면 C++의 법을 따릅시다.항목 1. C++를 언어들의 연합체(federation) 로 바라보는 안목은 필수C++는 한 가지 프로그래밍 규칙 아래 구성된 통합언어(unified language)가 아니라 네 가지 하위 언어들의 연합체(federation) 라고 보는 것이 언어를 이해하기에 좋다. C 블록, 문장, 선행 처리자, 기본제공 데이터타입, 배열, 포인터 etc… OOP로써의 C++ 클래스를 사용하는 C : 클래스 , 캡슐화, 상속, 다형성, 가상 함수 etc 템플릿 C++ Template Meta-programming : TMP STL 템플릿 라이브러리 : container / iterator / algorithm / function object 항목 2. #define을 쓰려거든const, enum, inline을 떠올리자.매크로인 #define를 수식이나 상수에 사용하는 것은 떄때로 예측할 수 없는 결과를 가져올 수 있으며 , 디버깅에 있어서 비효율적이다. 일례로 아래와 같은 컴파일 에러를 생각해 보자. 123// Bad Example#define ASPECT_RATIO 1.563int ratio = ASPECT_RATIO / 0; 컴파일러로 코드가 넘어간 후에는ASPECT_RATIO가 symbolic name으로 남지 않고,숫자 상수로 대체되어 버린다. 때문에 컴파일러의 기호 테이블에 들어가 있기 때문에 컴파일 에러라도 나면, 복잡한 코드에서는 이를 바로잡기가 쉽지 않다. 특히나 매크로 함수는 큰 재앙이 될 수도 있다. 12345// Bad Example#define CALL_WITH_MAX(a,b) f((a) &gt; (b) ? (a) : (b))int a=5, b=0;CALL_WITH_MAX(++a, b);CALL_WITH_MAX(++a, b + 10); 위와 함수의 경우 a는 7이 되고, 아래의 경우는 6이 되어버린다. 의도되지 않은 결과가 나와버린다. 상수를 선언하는 올바른 코드는 아래와 같다. 12// Good Exampleconst double AspectRatio = 1.653; 클래스 안에서 상수를 사용하고 싶을 때는 static const 혹은 enum을 사용하자. 123456// Good Exampleclass ConstEstimate&#123;private: static const double FudgeFactor = 1.35; enum &#123; NumTurns = 5&#125;;&#125; 매크로 함수의 경우, template function을 사용하면 매크로의 효율적인 코드의 측면을 가져갈 수 있다.123456// Good Exampletemplate&lt;typename T&gt;inline void callWithMax (const T&amp; a, const T&amp; b)&#123; f(a &gt; b ? a : b);&#125; 항목 3. 낌새만 보이면 const를 들이대 보자.const는 컴파일러가 해당 변수 값에 대한 제약을 단단히 지켜준다는 점에서 강력하고 매력적인 도구이다. 다양한 const의 사용 예를 분석해 보자. 1234char *p = greeting; // non-const pointer, non-const dataconst char *p = greeting; // non-const pointer, const datachar *const p = greeting; // const pointer, non-const dataconst char *const p = greeting // const pointer, const data 규칙이 조금은 헷갈리긴 하지만 표시를 기준으로, 왼쪽에 const는 data를 상수로 취취한다. 반면 오른쪽에 있는 const는 포인터 자체를 상수로 취하게 된다. 이는 다음 예를 통해 좀 더 명확히 구분이 가능하다. 12void f1(const int *pw); // non-const pointer, const datavoid f2(int const *pw); // non-const pointer, const data 위의 두 가지 경우에 대해서 모두 가능한 문법이며, 둘 다 int 형의 data가 상수임을 의미한다. f1 방식이 일반적이긴 하나, 둘 다 옳은 표현식이므로 기억해두자. 상수 객체를 생성할 경우에는 그에 맞추어 상수 멤버함수도 정의해줄 필요가 있다. 다음 예제를 보자. 12345678910111213141516#include &lt;iostream&gt;class TextBlock&#123; public: const char&amp; operator[](std::size_t pos) const &#123; return text[position];&#125; char&amp; operator[](std::size_t pos) &#123; return text[position];&#125;&#125;int main()&#123; TextBlock tb(\"Hello\"); std::cout &lt;&lt; tb[0]; const TextBlock ctb(\"World\"); std::cout &lt;&lt; ctb[0]; return 0;&#125; const char&amp; operator[] (std::size_t pos) const에서 중요한 점은 앞의 const는 return 값인 char&amp;가 상수임을 뜻한다. 반면 뒤의 const는 이 멤버 함수가 상수형으로 정의되었으며, 이는 상수 객체에 대해서 적용되는 함수임을 나타내는 부분이다. 추가적으로 공부가 더 필요한 부분 비트수준 상수성(bitwise constness) / 논리적 상수성(logical constness) const_cast, static_cast의 사용 방법 및 사용 예시 이해 항목 4. 객체를 사용하기 전에 반드시 그 객체를 초기화하자.초기화 되지 않은 채 생성된 변수들은 어디에선가 큰 문제를 일으킬 소지가 다분하다. 정의되지 않은 동작이 발생할 가능성이 높기 때문이다. 최악의 경우에는 어떤 플랫폼에서 미초기화 객체를 읽기만 해도 프로그램이 다운되기도 한다. 디버깅을 최대한 줄이기 위해서는 초기화를 하는 것이 효과적이다. built-in type의 객체들은 직접 손으로 초기화하자. 생성자에서는 멤버 초기화 리스트를 사용하자. non-local한 객체는 local하게 바꾸어 사용하자. (non-local한 객체를 만들면 translation unit 단계에서 정의되지 않은 동작이 일어날 수 있다.) Bad Exampleglobal한 변수인 tfs가 중간에 컴파일러 상 어떤 멤버 초기화 과정을 뒤죽박죽으로 할 지 알 수 없어서 위험하다. 1234567class FileSystem&#123; public: std::size_t numDisks() const; ...&#125;extern FileSystem tfs; std::sizet disks = tfs.numDisks(); // bad Example Good Exampletfs()가 local하게 선언되어 있으며, 이는 C++ 컴파일러상 반드시 멤버 초기화 과정을 거치므로 안전하다. 12345678910class FileSystem&#123; public: std::size_t numDisks() const; ...&#125;FileSystem&amp; tfs()&#123; static FileSYstem fs; return fs;&#125;std::sizet disks = tfs().numDisks(); // good example","categories":[{"name":"Programming_Language","slug":"Programming-Language","permalink":"https://huklee.github.io/categories/Programming-Language/"},{"name":"C++","slug":"Programming-Language/C","permalink":"https://huklee.github.io/categories/Programming-Language/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://huklee.github.io/tags/C/"},{"name":"EC++","slug":"EC","permalink":"https://huklee.github.io/tags/EC/"}]},{"title":"Timezone Test","slug":"003.Timezone-Test","date":"2016-11-25T08:20:26.000Z","updated":"2017-01-18T00:02:29.000Z","comments":true,"path":"2016/11/25/003.Timezone-Test/","link":"","permalink":"https://huklee.github.io/2016/11/25/003.Timezone-Test/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Swift Tutorial","slug":"002.Swift-Tutorial","date":"2016-11-25T08:12:10.000Z","updated":"2017-01-18T00:02:30.000Z","comments":true,"path":"2016/11/25/002.Swift-Tutorial/","link":"","permalink":"https://huklee.github.io/2016/11/25/002.Swift-Tutorial/","excerpt":"","text":"Swift TutorialSwift Tutorial pageSwift Playground","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://huklee.github.io/categories/Tutorial/"},{"name":"Swift","slug":"Tutorial/Swift","permalink":"https://huklee.github.io/categories/Tutorial/Swift/"}],"tags":[{"name":"Swift, Cocoa, AppCode","slug":"Swift-Cocoa-AppCode","permalink":"https://huklee.github.io/tags/Swift-Cocoa-AppCode/"}]},{"title":"Hello World","slug":"001.hello-world","date":"2016-11-20T15:10:23.000Z","updated":"2017-03-01T06:58:41.000Z","comments":true,"path":"2016/11/21/001.hello-world/","link":"","permalink":"https://huklee.github.io/2016/11/21/001.hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment How to write down markdown documentsUsing tags How to use code blocks 1234567&#123;% codeblock title lang:Cpp %&#125;#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; &quot;Hello world, C++ &quot; &lt;&lt; endl;&#125;&#123;% endcodeblock %&#125; title12345#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; \"Hello world, C++ \" &lt;&lt; endl;&#125; youtube tag 1&#123;% youtube -n_xSSkRl-c %&#125; gist 1&#123;% gist 89a6730c2b1a220c733a7145ec1194ca %&#125; Useful linksMarkdown cheet sheet Hexo plugin cheat sheet","categories":[],"tags":[]}]}